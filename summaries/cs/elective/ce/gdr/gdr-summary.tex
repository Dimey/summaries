\documentclass[a4paper, 11pt, accentcolor = tud3b]{tudreport}

% Core packages.
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
% Other packages.
\usepackage[german, ruled, vlined, linesnumbered]{algorithm2e}
\usepackage{caption}
\usepackage{csquotes}
\usepackage{enumitem}
\usepackage[mathcal]{euscript} % Get readable mathcal font.
\usepackage{float}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{siunitx}
\usepackage{qtree}
\usepackage{stmaryrd}
\usepackage{tabto}
\usepackage{tikz}
\usepackage[disable]{todonotes}
\usetikzlibrary{arrows.meta, shapes, backgrounds, angles, calc, decorations.markings}

% Basic information.
\title{Grundlagen der Robotik}
\subtitle{Zusammenfassung \\ Fabian Damken}
\author{Fabian Damken}
\date{\today}

% Description-list styling.
\SetLabelAlign{parright}{\parbox[t]{\labelwidth}{\raggedleft#1}}
\setlist[description]{style = multiline, leftmargin = 4cm, align = parright}

\tikzset{> = { Latex[length = 2.5mm] }}
\tikzstyle{every path} = [ very thick ]

\MakeOuterQuote{"}

% New commands.
\DeclareMathOperator{\total}{d}
\newcommand{\dif}[1]{\,\total#1}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\given}{\,\vert\,}
% Matrix/Vector notation.
\makeatletter
\newcommand{\mat}[1]{\boldsymbol{#1} \ifthenelse{\equal{#1}{A}}{}{\@ifnextchar({}{\@ifnextchar[{}{\@ifnextchar\{{}{\@ifnextchar\,{}{\!}}}}}}
\renewcommand{\vec}[1]{\boldsymbol{#1} \ifthenelse{\equal{#1}{A}}{}{\@ifnextchar({}{\@ifnextchar[{}{\@ifnextchar\{{}{\@ifnextchar\,{}{\!}}}}}}
\makeatother
% Abbreviations.
\renewcommand{\dh}{d.\,h.~}
\newcommand{\bzw}{bzw.~}
\newcommand{\bspw}{bspw.~}
\newcommand{\bzgl}{bzgl.~}
\newcommand{\zB}{z.\,B.~}
\newcommand{\iA}{i.\,A.~}
\newcommand{\ggf}{ggf.~}
\newcommand{\mglw}{mglw.~}
\newcommand{\vs}{vs.~}

% Quadtree.
\newcommand{\grayBox}{%
	\begin{tikzpicture}
	\draw [fill = gray] (0, 0) -- (0, 0.5) -- (0.5, 0.5) -- (0.5, 0) -- cycle;
	\end{tikzpicture}
}
\newcommand{\whiteBox}{%
	\begin{tikzpicture}
	\draw [fill = white] (0, 0) -- (0, 0.5) -- (0.5, 0.5) -- (0.5, 0) -- cycle;
	\end{tikzpicture}
}
\newcommand{\blackBox}{%
	\begin{tikzpicture}
	\draw [fill = black] (0, 0) -- (0, 0.5) -- (0.5, 0.5) -- (0.5, 0) -- cycle;
	\end{tikzpicture}
}

% https://tex.stackexchange.com/a/333383
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
	\hskip -\arraycolsep
	\let\@ifnextchar\new@ifnextchar
	\array{#1}}
\makeatother

\begin{document}
	\maketitle
	\tableofcontents
	\listoftodos

	\chapter{Einleitung} % 1.8
		\todo{Content}
		
		\section{Was ist ein Roboter?} % 1.9, 1.10, 1.11, 1.12, 1.13, 1.14
			\todo{Content}
		% end

		\section{Was ist KI?} % 1.15, 1.16, 1.17, 1.18, 1.19
			\todo{Content}
		% end

		\section{Was ist Robotik?} % 1.20, 1.21, 1.22
			\todo{Content}
		% end

		\section{Sense -- Plan -- Act} % 1.27
			\todo{Content}

			\paragraph{Act} % N/A
				\todo{Content}

				\subparagraph{Kinematik} % 1.28, 1.29, 1.30, 1.31, 2.32, 1.33, 1.34, 1.35
					\todo{Content}
				% end

				\subparagraph{Dynamik} % 1.36, 1.37
					\todo{Content}
				% end

				\subparagraph{Steuerung} % 1.38, 1.39, 1.40, 1.41
					\todo{Content}
				% end
			% end

			\paragraph{Sense} % N/A
				\todo{Content}

				\subparagraph{Sensoren} % 1.42, 1.43, 1.44, 1.45
					\todo{Content}
				% end
			% end

			\paragraph{Plan} % N/A
				\todo{Content}

				\subparagraph{Lokalisierung, Kartographie, Navigation, Bahnplanung} % 1.46, 1.47, 1.48, 1.49
					\todo{Content}
				% end
			% end
		% end

		\section{Geschichte der Robotik} % 1.50
			\todo{Content}

			\subsection{Historische Entwicklung} % 1.51, 1.54, 1.55
				\todo{Content}
			% end

			\subsection{Die drei Gebote der Robotik} % 1.52, 1.53
				\todo{Content}
			% end

			\subsection{Autonome Fahrzeuge} % 1.59
				\todo{Content}
			% end

			\subsection{Entwicklungstrend} % 1.60
				\todo{Content}
			% end
		% end

		\section{Herausforderungen} % 1.61
			\todo{Content}

			\subsection{Humanoide Bewegung} % 1.61, 1.61, 1.63, 1.64, 1.65, 1.66, 1.67, 1.68, 1.69
				\todo{Content}
			% end

			\subsection{Roboter für menschliche Mobilität} % 1.112, 1.113, 1.114, 1.115, 1.116, 1.117, 1.118, 1.119, 1.120, 1.121, 1.122, 1.123
				\todo{Content}
			% end

			\subsection{Roboter-Avatare} % 1.70
				\todo{Content}

				\subsubsection{Beine} % 1.74, 1.75, 1.76, 1.77, 1.78, 1.79, 1.80, 1.81, 1.82, 1.83, 1.84
					\todo{Content}
				% end

				\subsubsection{Katastrophenbewältigung und -hilfe} % 1.71, 1.72, 1.73, 1.87, 1.88, 1.89, 1.90, 1.91, 1.92, 1.93, 1.94
					\todo{Content}
				% end

				\subsubsection{Objekt-Vorlagen} % 1.95, 1.96, 1.97, 1.98
					\todo{Content}
				% end

				\subsubsection{Greifen und Manipulation} % 1.99, 1.100, 1.101, 1.102, 1.103, 1.104, 1.105, 1.106, 1.107, 1.108, 1.109
					\todo{Content}
				% end
			% end

			\subsection{Die Robotik an sich} % 1.124, 1.125, 1.126, 1.127, 1.128
				\todo{Content}
			% end
		% end
	% end

	\chapter{Räumliche Darstellungen und Transformationen} % S.11
		\todo{Content}

		\section{Mathematische Grundlagen und Notation} % S.11, 2.1
			\todo{Content}

			\subsection{Vektoren} % S.11, 2.2, 2.3
				\todo{Content}
			% end

			\subsection{Matrizen} % S.12, S.13, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 2.10, 2.11
				\todo{Content}
			% end
		% end

		\section{Koordinatensysteme} % S.14, 2.12, 2.13
			\todo{Content}

			\subsection{Position} % S.15, 2.14
				\todo{Content}
			% end

			\subsection{Orientierung} % S.16, 2.15, 2.16
				\todo{Content}
			% end
		% end

		\section{Klassische Transformationsbeziehungen} % S.17, 2.17, 2.18
			\todo{Content}
		% end

		\section{Rotation eines Koordinatensystems} % S.18, 2.20
			\todo{Content}

			\subsection{Rotationsmatrizen} % S.18, S.19, 2.21, 2.22, 2.23
				\todo{Content}
			% end

			\subsection{Verkettete Rotationen} % S.19, S.20, S.21, 2.24, 2.25, 2.26, 2.27, 2.28
				\todo{Content}
			% end

			\subsection{Winkelparameter} % S.22, 2.29, 2.35, 2.36
				\todo{Content}

				\subsubsection{RPY-Winkel} % S.22, S.22, 2.30, 2.31, 2.32, 2.33
					\todo{Content}
				% end

				\subsubsection{Euler-Winkel} % S.23, S.24, 2.34
					\todo{Content}
				% end

				\subsubsection{Kardan-Winkel} % S.23, S.24, 2.35
					\todo{Content}
				% end
			% end
		% end

		\section{Homogene Transformationen} % S.24, S.25, S.26, 2.19, 2.37, 2.38, 2.39, 2.40, 2.41, 2.42, 2.43
			\todo{Content}
		% end

		\section{Berechnungseffizienz} % S.26, S.27
			\todo{Content}
		% end
	% end

	\chapter{Roboterkinematik} % S.28
		\todo{Content}

		\section{Vorwärtskinematik} % S.28
			\todo{Content}

			\subsection{Kinematische Ketten} % S.28, S.29
				\todo{Content}
			% end

			\subsection{Kinematische Modellbildung} % S.30, S.31
				\todo{Content}
			% end

			\subsection{Denavit-Hartenberg (DH) Konventionen} % S.31, S.32, S.33, S.34, S.35
				\todo{Content}

				\subsubsection{Beispiel: SCARA-Manipulator} % S.36, S.37, S.38
					\todo{Content}
				% end

				\subsubsection{Beispiel: 2-DOF-Schub-Drehgelenk-Arm} % S.38, S.39
					\todo{Content}
				% end
			% end
		% end

		\section{Rückwärtskinematik (Inverse Kinematik)} % S.40, S.41, S.42
			\todo{Content}

			\subsection{Numerische Berechnung} % S.43, S.44
				\todo{Content}
			% end

			\subsection{Analytische Lösung} % S.45, S.46
				\todo{Content}

				\subsubsection{Beispiel: Ebener SCARA-Manipulator} % S.46, S.47
					\todo{Content}
				% end
			% end

			\subsection{Geometrische Ermittlung der analytischen Lösung} % S.48
				\todo{Content}
			% end

			\subsection{Algorithmische Ermittlung der analytischen Lösung} % S.49
				\todo{Content}
			% end
		% end

		\section{Genauigkeit des kinematischen Modells} % S.50
			\todo{Content}
		% end

		\section{Modellierung von Roboterbeinen und -armen} % S.51
			\todo{Content}

			\subsection{Dreigelenkiges Bein eines vierbeinigen Roboters} % S.51
				\todo{Content}
			% end

			\subsection{Sechsgelenkiges Bein eines humanoiden Roboters} % S.52, S.53
				\todo{Content}
			% end

			\subsection{Arm eines humanoiden Roboters} % S.54
				\todo{Content}
			% end
		% end
	% end

	\chapter{Geschwindigkeit, Jacobi-Matrix und statische Kräfte} % S.55, S.56, S.57, S.58, S.59
		\todo{Content}

		\section{Schiefsymmetrische Matrizen, Vektoren der Winkelgeschwindigkeiten und -beschleunigungen} % S.60, S.61, S.62
			\todo{Content}

			\subsection{Relative Beschleunigung zwischen \(S_n\) und \(S_0\)} % S.63
				\todo{Content}
			% end
		% end

		\section{Jacobi-Matrix eines Manipulators} % S.64
			\todo{Content}

			\subsection{Addition von Winkelgeschwindigkeiten} % S.64, S.65
				\todo{Content}
			% end

			\subsection{Herleitung} % S.66
				\todo{Content}

				\subsubsection{Drehwinkelgeschwindigkeit} % S.67, S.68
					\todo{Content}
				% end

				\subsubsection{Lineare Geschwindigkeit} % S.69, S.70, S.71
					\todo{Content}
				% end

				\subsubsection{Zusammenfassung} % S.72
					\todo{Content}
				% end
			% end

			\subsection{Beispiel: Ebener SCARA-Manipulator} % S.73, S.74
				\todo{Content}
			% end
		% end

		\section{Inverses Jacobi-Modell} % S.75
			\todo{Content}

			\subsection{Geschwindigkeitssteuerung} % S.75, S.76, S.77
				\todo{Content}

				\subsubsection{Beispiel: SCARA-Manipulator} % S.77, S.78, S.79
					\todo{Content}
				% end
			% end
		% end

		\section{Kinematische Singularitäten} % S.79, S.80, S.83
			\todo{Content}

			\subsection{Beispiel: SCARA-Manipulator} % S.80, S.81
				\todo{Content}
			% end

			\subsection{Beispiel: Typischer Industrieroboter mit 6 Drehgelenken} % S.81, S.82
				\todo{Content}
			% end

			\subsection{Weitere Beispiele} % S.82
				\todo{Content}
			% end

			\subsection{Vermeidung} % S.82, S.83
				\todo{Content}
			% end

			\subsection{Umgang mit unvermeidbaren Singularitäten} % S.83
				\todo{Content}
			% end
		% end

		\section{Nicht-holonome Kinematik mehrrädriger Fahrzeuge} % S.84, S.85
			\todo{Content}

			\subsection{Differentialantrieb} % S.86, S.87, 4.2
				\todo{Content}
			% end

			\subsection{Allgemeines Vorwärtskinematikproblem für Fahrzeuge} % S.87, S.88, S.89, S.90
				\todo{Content}
			% end

			\subsection{Inverses Kinematikproblem} % S.90, S.91
				\todo{Content}
			% end

			\subsection{Omnidirektionale Dreirad-Kinematik} % S.91, S.92
				\todo{Content}
			% end

			\subsection{Weitere Antriebsarten von Fahrzeugen} % S.92, 4.5
				\todo{Content}
			% end
		% end

		\section{Statische Kräfte bei Manipulatoren} % S.92
			\todo{Content}
		% end
	% end

	\chapter{Roboterdynamik} % S.93, S.94, S.95
		\todo{Content}

		\section{Massenverteilung eines Starrkörpers} % S.96, S.97, S.98
			\todo{Content}
		% end

		\section{Newton-Euler Formulierung der Roboterdynamik} % S.99, S.100, S.110, S.118, S.119
			\todo{Content}

			\subsection{Iterative Berechnung von INV DYN} % S.101, S.102, S.103, S.104, S.105, S.106, S.107, S.108, S.109
				\todo{Content}
			% end

			\subsection{Zusammenfassung} % S.109, S.110
				\todo{Content}
			% end

			\subsection{Beispiel: SCARA-Manipulator} % S.111, S.112, S.113, S.114, S.115, S.116, S.117
				\todo{Content}
			% end
		% end

		\section{Lagrangesche Formulierung der Roboterdynamik} % S.120
			\todo{Content}

			\subsection{Kinetische und potentielle Energie, Lagrangefunktion} % S.120, S.122
				\todo{Content}

				\subsubsection{Kinetische Energie} % S.120
					\todo{Content}
				% end

				\subsubsection{Potentielle Energie} % S.121
					\todo{Content}
				% end

				\subsubsection{Lagrangefunktion} % S.121, S.122
					\todo{Content}
				% end
			% end

			\subsection{Beispiel: SCARA-Manipulator} % S.123, S.124, S.125, S.126, S.127, S.128, S.129
				\todo{Content}
			% end
		% end

		\section{Numerische Aspekte} % S.130
			\todo{Content}

			\subsection{Modularität} % S.130
				\todo{Content}
			% end

			\subsection{Simulation} % S.131
				\todo{Content}
			% end
		% end

		\section{Rekursive Verfahren zur Berechnung der Vorwärtsdynamik} % S.131
			\todo{Content}

			\subsection{Verfahren mit expliziter Berechnung der Massenmatrix} % S.132
				\todo{Content}

				\subsubsection{Verfahren 1: Berechnung von \(M\) durch wiederholte Auswertung des Newton-Euler-Verfahrens} % S.132, 5.20
					\todo{Content}
				% end

				\subsubsection{Verfahren 2: Ausnutzen der Symmetrie von \(M\)} % S.132, S.133, 5.20
					\todo{Content}
				% end

				\subsubsection{Verfahren 3: Aggregation von Teilmanipulatoren (CRBA)} % S.133, S.134, 5.20
					\todo{Content}
				% end

				\subsubsection{Vergleich der Verfahren} % S.135
					\todo{Content}
				% end
			% end

			\subsection{Verfahren ohne explizite Berechnung der Massenmatrix} % S.135, 5.22, 5.23, 5.24
				\todo{Content}
			% end

			\subsection{Multibody Systems Library MBSlib} % 5.25, 5.26, 5.27, 5.28, 5.29, 5.31, 5.32
				\todo{Content}

				\subsubsection{Beispiele} % 5.29, 5.30, 5.33, 5.34, 5.35, 5.36, 5.37
					\todo{Content}
				% end
			% end

		\section{Geschlossene kinematische Ketten} % S.136
			\todo{Content}
		% end

		\section{Berücksichtigung von Nichtstarrkörpereffekten} % S.137, 5.39
			\todo{Content}

			\subsection{Reibung} % S.137, S.138, 5.40, 5.41
				\todo{Content}

				\subsubsection{Reibungsmodell} % 5.42
					\todo{Content}

					\paragraph{Haftung} % 5.43
						\todo{Content}
					% end

					\paragraph{Stribeck-Reibung} % 5.44
						\todo{Content}
					% end

					\paragraph{Coloumbsche Reibung} % S.138
						\todo{Content}
					% end

					\paragraph{Viskose Gleitreibung} % S.138, S.139
						\todo{Content}
					% end
				% end
			% end

			\subsection{Elastizität} % S.139, 5.45, 5.46
				\todo{Content}

				\subsubsection{Grundlagen} % S.139, S.140, 5.47, 5.48, 5.49
					\todo{Content}
				% end

				\subsubsection{Elastizitäten in der Robotik} % S.141, S.142, S.143, S.144, 5.50, 5.51
					\todo{Content}

					\paragraph{Ersatzmodell} % 5.52
						\todo{Content}
					% end

					\paragraph{Dynamikgleichungen} % 5.53, 5.54, 5.55, 5.56
						\todo{Content}
					% end
				% end

				\subsubsection{Berechnung von INV DYN bei Drehgelenkelastizitäten} % S.145, 5.57, 5.58
					\todo{Content}
				% end

				\subsubsection{Elastizitäten in der Biologie} % S.146, 5.59, 5.60
					\todo{Content}

					\paragraph{Menschlicher Bewegungsapparat} % 5.61, 5.62, 5.63
						\todo{Content}

						\subparagraph{Gelenkmodelle} % 5.64, 5.65
							\todo{Content}
						% end

						\subparagraph{Skelettmuskulatur} % 5.66
							\todo{Content}
						% end

						\subparagraph{Muskel-Sehnen-Komplex} % 5.67, 5.68, 5.69
							\todo{Content}
						% end
					% end

					\paragraph{Muskelaktivierungsdynamik} % 5.70
						\todo{Content}

						\subparagraph{Muskelmodell} % 5.71, 5.72, 5.73
							\todo{Content}
						% end

						\subparagraph{Hebelarme} % 5.74
							\todo{Content}
						% end
					% end

					\paragraph{Weichteilmodelle} % 5.75, 5.76
						\todo{Content}
					% end

					\paragraph{Dynamikmodell} % 5.77
						\todo{Content}

						\subparagraph{Dynamiksimulation} % 5.78, 5.79, 5.80, 5.81, 5.82, 5.83
							\todo{Content}
						% end
					% end

					\paragraph{Software und Daten} % 5.84
						\todo{Content}
					% end

					\paragraph{Einschränkungen} % 5.85
						\todo{Content}
					% end
				% end

				\subsubsection{Steuerung und Regelung bei Mensch und Tier} % 5.87, 5.88
					\todo{Content}

					\paragraph{Reafferenzprinzip} % 5.89, 5.90, 5.91
						\todo{Content}
					% end
				% end
			% end
		% end

		\section{Spezielle Dynamikmodelle für zweibeinige, humanoide Roboter und deren Stabilitätsregelung} % S.147, 5.97, 5.98, 5.99
			\todo{Content}

			\subsection{Stabilität zweibeiniges Laufen} % 5.100, 5.101, 5.102
				\todo{Content}
			% end

			\subsection{Dynamik im Roboterstandfuß} % 5.104, 5.105, 5.106, 5.107, 5.108
				\todo{Content}
			% end

			\subsection{Zero-Moment-Point} % S.148, S.149, S.149, S.150, 5.109
				\todo{Content}
			% end

			\subsection{Center of Pressure (CoP)} % 5.110
				\todo{Content}
			% end

			\subsection{ZMP Preview Walking} % 5.111, 5.112, 5.113, 5.114, 5.115, 5.116
				\todo{Content}
			% end

			\subsection{Globale Stabilitätsbegriffe} % S.156, S.157
				\todo{Content}
			% end

			\subsection{Ausblicke} % N/A
				\todo{Content}

				\subsubsection{Capture Steps} % 5.117, 5.118
					\todo{Content}
				% end

				\subsubsection{Whole Body Control} % 5.119, 5.120, 5.121, 5.122
					\todo{Content}
				% end

				\subsubsection{Unebenes Terrain} % 5.123
					\todo{Content}
				% end
			% end
		% end

		\section{Spezielle Dynamikmodelle für zweibeinige, nicht-humanoide Roboter und deren Stabilitätsregelung} % 5.125, 5.126
			\todo{Content}

			\subsection{Inverses Pendel} % S.150, S.151, S.152, S.153, 5.127
				\todo{Content}
			% end

			\subsection{Erweitertes Modell des menschlichen Gehens und Rennens} % S.153, 5.128, 5.129
				\todo{Content}

				\subsubsection{Feder-Masse-Modell (Rennen)} % S.153, S.154, S.155
					\todo{Content}
				% end

				\subsubsection{Feder-Masse-Modell (Gehen)} % S.153, S.155
					\todo{Content}
				% end
			% end

			\subsection{Hüpfende Roboter mit Teleskop-Beinen} % 5.130, 5.131, 5.132, 5.138
				\todo{Content}

				\subsubsection{Ein Modell dynamischer Stabilität} % 5.134, 5.135, 5.136, 5.137
					\todo{Content}
				% end
			% end

			\subsection{Passive Dynamic Walkers} % 5.142, 5.143, 5.144, 5.145, 5.147, 5.148, 5.149
				\todo{Content}
			% end

			\subsection{Elastische Roboter} % 5.150, 5.151, 5.152, 5.153, 5.154, 5.160, 5.164
				\todo{Content}
			% end
		% end
	% end

	\chapter{Antriebssysteme}
		\section{Gebräuchliche Antriebssysteme}
			\subsection{Hydraulische Antriebe}
				Hydraulische Antriebe nutzen Öl und Druckveränderungen dieses Öls in einer Kammer zur Bewegung.
				
				\begin{itemize}
					\item \textbf{Vorteile:}
						\begin{itemize}
							\item Können hohe Lasten tragen.
							\item Gutes Verhältnis von Leistung zu Gewicht.
							\item Durch die Inkompressibilität von Öl kann der Antrieb gut in einer Stellung fixiert werden.
							\item Der Antrieb schmiert und kühlt sich selbstständig.
							\item Schnelle Reaktionszeit.
							\item Sicher in Umgebungen mit brennbaren Gasen (da keine Funken entstehen).
							\item Flüssige Bewegungen sind auch bei langsamer Geschwindigkeit möglich.
						\end{itemize}
					\item \textbf{Nachteile:}
						\begin{itemize}
							\item Teuer.
							\item Die Dichtungen müssen gut gewartet werden, sonst entstehen Lecks.
							\item Stark limitierte Geschwindigkeiten.
							\item Benötigen eine Rückführleitung.
							\item Können aufgrund der hohen Leitungsdrücke und -flüsse schlecht klein gebaut werden (Miniaturisierung).
							\item Großer Platzbedarf für externe Leistungsversorgung.
							\item Das Regel- und Positionierverhalten ist Temperaturabhängig.
						\end{itemize}
				\end{itemize}
			
				Daher gibt es nur wenige mobile hydraulisch aktuierte Roboter (\zB Atlas und BigDog von Boston Dynamics).
			% end

			\subsection{Pneumatische Antriebe}
				Pneumatische Antriebe nutzen Pressluft und Veränderungen des Drucks zur Bewegung.
				
				\begin{itemize}
					\item \textbf{Vorteile:}
						\begin{itemize}
							\item Preiswert.
							\item Pressluft ist in der Industrie überall verfügbar.
							\item Hohe Geschwindigkeiten sind möglich.
							\item Keine Verunreinigung durch auslaufende Flüssigkeiten (wie Öl).
							\item Reine Rückführleitungen nötig.
							\item Aufgrund der Kompressibilität von Luft gibt der Antrieb auf natürliche Weise nach: vorteilhaft für Interaktionen mit Menschen.
						\end{itemize}
					\item \textbf{Nachteile:}
						\begin{itemize}
							\item Die Kompressibilität der Luft beschränkt die Regel- und Positionierbarkeit (der Roboter kann nicht gut in einer Position fixiert werden).
							\item Die entweichende Luft erzeugt Lärm.
							\item Zusätzliches Trocknen/Filtern der Luft kann erforderlich sein.
							\item Das hochheben von Lasten und Druckabfälle in der Leitung erschweren die Regelung.
							\item Ungeeignet für mobile Anwendung, da ein Kompressor benötigt wird.
						\end{itemize}
				\end{itemize}
			% end

			\subsection{Elektrische Antriebe}
				\begin{itemize}
					\item \textbf{Vorteile:}
						\begin{itemize}
							\item Schnelligkeit und Genauigkeit.
							\item Es sind ausgefeilte Regelungsmethoden anwendbar.
							\item Preiswert.
							\item Neue Motortypen werden schnell entwickelt, \bzw können schnell entwickelt werden.
						\end{itemize}
					\item \textbf{Nachteile:}
						\begin{itemize}
							\item Typischerweise haben die Motoren hohe Geschwindigkeiten bei niedrigem Drehmoment, \dh es sind Getriebe notwendig.
							\item Das Getriebespiel beschränkt die erreichbare Genauigkeit.
							\item Elektrische Lichtbögen (Funken, Blitze) sind problematisch bei entzündlicher Atmosphäre (\zB innerhalb von entzündlichen Gasen).
							\item Im Dauereinsatz ist eine Überhitzung möglich.
							\item Es sind Bremsen notwendig, um eine Position dauerhaft zu fixieren.
						\end{itemize}
				\end{itemize}
			% end
		% end

		\section{DC-Bürsten-Motoren}
			Durch das anlegen einer Spannung an den \emph{Bürsten}, die den \emph{Kollektor} berühren, wird eine Spannung induziert. Durch die Rotorwicklung wird ein magnetisches Felds erzeugt, was das magnetische Fels des Permanentmagneten verzerrt. Das hieraus resultierende Drehmoment führt zur Bewegung des Kollektors. Durch das Reiben der Bürsten an dem Kollektor entstehen Funken, die in einer entzündlichen Umgebung zu Bränden führen können.
			
			Abbildung~\ref{fig:dc_brush_engine_circuit} zeigt den elektrischen Stromkreis eines DC-Bürsten-Motors mit allen relevanten elektrischen Größen. Mit der Drehzahlkonstante \(k_v\) sowie der Drehmomentkonstante \(k_t\) und den mechanischen Größen des Motordrehmoments \(\tau_r\) und der Motorgeschwindigkeit \(\dot{\theta}_r\) wird der Stromkreis durch folgende ()Differential-) Gleichungen beschrieben:
			\begin{align*}
				u_C            & = R_a i_a + L_a \frac{\total i_A}{\total t} + u_\mathit{ind} \tag{Ankerstromkreis}     \\
				u_\mathit{ind} & = \dot{\theta}_r k_v                                         \tag{Induzierte Spannung} \\
				\tau_r         & = i_a k_t                                                    \tag{Motordrehmoment}
			\end{align*}
			
			\begin{figure}
				\centering
				\begin{tikzpicture}
					\node [draw, circle] (a) at (0, 0) {};
					\node [draw, circle] (b) at (0, -2) {};
					\node [draw, circle] (c) at (7, -1) {M};
					
					\draw (a.north)
						to (0, 1)
						to (1.5, 1);
						
					% Resistor.
					\draw (1.5, 1)
						to (1.5, 1.25)
						to (3, 1.25)
						to (3, 0.75)
						to (1.5, 0.75)
						to cycle;
					
					\draw (3, 1) to (4, 1);
					
					% Coil.
					\draw[fill = black] (4, 1)
						to (4, 1.25)
						to (5.5, 1.25)
						to (5.5, 0.75)
						to (4, 0.75)
						to cycle;
					
					\draw (5.5, 1) -| (c.north);
					
					\draw (c.south)
						to (7, -3)
						to (0, -3)
						to (b.south);
					
					\draw [->] (1.5, 1.5) to node[label = above:{\( u_R \)}, yshift = -5pt]{} (3, 1.5);
					\draw [->] (4, 1.5) to node[label = above:{\( u_L \)}, yshift = -5pt]{} (5.5, 1.5);
					
					\path (1.5, 0.5) to node[label = below:{\( R_a \)}, yshift = 11pt]{} (3, 0.5);
					\path (4, 0.5) to node[label = below:{\( L_a \)}, yshift = 11pt]{} (5.5, 0.5);
					
					\coordinate [xshift = 0.6cm] (C1) at (c.north);
					\coordinate [xshift = 0.6cm] (C2) at (c.south);
					\draw [->] (C1) to node[label = right:{\( u_\mathit{ind} \)}]{} (C2);
					
					\coordinate [yshift = -0.1cm] (A) at (a.south);
					\coordinate [yshift = 0.1cm] (B) at (b.north);
					\draw [->] (A) to node[label = left:{\( u_C \)}, xshift = 5pt]{} (B);
					
					\draw [->] (7, 1) to node[label = right:{\( i_a \)}, xshift = -5pt]{} (7, 0.25);
				\end{tikzpicture}
				\caption{Stromkreis eines DC-Bürsten-Motors mit dem Widerstand der Spule \(R_a\), der Induktivität der Spule \(L_a\), dem Ankerstrom \(i_a\), der angelegten Spannung \(u_a\) und der induzierten Spannung \(u_\mathit{ind}\).}
				\label{fig:dc_brush_engine_circuit}
			\end{figure}
		% end

		\section{Getriebe}
			Direkte Elektrische Antriebe produzieren hohe Geschwindigkeiten bei geringen Drehmomenten. Daher ist ein \emph{Getriebe} zur Übersetzung notwendig, wenn hohe Drehmomente gewünscht sind (dies ist meistens der Fall, \bspw wenn schwere Lasten gehoben werden sollen). Zu den gebräuchlichsten Getriebe-Bauarten zählen Gewinde, Riemen-, Ketten oder Seilzug-Getriebe sowie Rädergetriebe. Diese werden in den folgenden Abschnitten detaillierter behandelt.
			
			Die \emph{Getriebeübersetzung} bezeichnet im Allgemeinen das Verhältnis von Eingangs- zu Austrittsgeschwindigkeit aus dem Getriebe. Dieses ist dabei gleich dem Verhältnis von Ausgangs- zu Eingangsdrehmoment:
			\begin{equation*}
				\text{Getriebeübersetzung} \coloneqq \frac{\text{Eingangsgeschwindigkeit}}{\text{Ausgangsgeschwindigkeit}} = \frac{\text{Ausgangsdrehmoment}}{\text{Eingangsdrehmoment}}
			\end{equation*}
			Bei elektrischen Antrieben werden vor allem \emph{Getriebeuntersetzungen} verwendet, die die Ausgangsdrehgeschwindigkeit reduzieren und das Ausgangsdrehmoment erhöhen.

			\subsection{Gewinde}
				Ein \emph{Gewinde} funktioniert wie eine "inverse Schraube", \dh eine Schraube mit Gewinde wird durch eine Platte bewegt, die sich daraufhin linear bewegt. Dies führt zu einer großen Geschwindigkeitsreduktion und damit zu einer starken Momenterhöhung. Durch die hohe Steifigkeit des Systems sind außerdem hohe Traglasten möglich.
			% end

			\subsection{Riemen-/Seilzug-Getriebe}
				Bei einem \emph{Riemen-} oder auch \emph{Seilzug-Gewinde} bestehen aus zwei unterschiedlich großen Rädern (\zB Zahnrädern) mit den Radien \(r_1\) und \(r_2\), die über einen Riemen verbunden sind (dabei ist \(r_1\) der Eingang, \dh dieses Rad wird von dem Motor gedreht.). Problematisch sind hier die auftretenden Elastizitäten im Riemen. Zur Vermeidung dieser muss der Riemen durchgehend gespannt bleiben.
				
				Die Getriebeübersetzung gleich dem Quotient der beiden Radien:
				\begin{equation*}
					\text{Getriebeübersetzung} = \frac{r_2}{r_1}
				\end{equation*}
			% end

			\subsection{Rädergetriebe}
				Bei Zahnrädern treten einige elementare Probleme auf:
				\begin{itemize}
					\item (Verdreh-) Spiel (\emph{Backslash}) durch ungenaue Verzahnung (\dh die Räder können ein bisschen hin und her gewackelt werden).
					\item Reibung zwischen den Rädern.
					\item Durch eine enge Verzahnung kann das Spiel verringert werden, dies führt aber zu einer höheren Reibung.
				\end{itemize}
			
				Gängige Typen von Zahnradgetrieben sind
				\begin{itemize}
					\item Stirnradgetriebe,
					\item Planetengetriebe und
					\item Harmonic Drive Getriebe.
				\end{itemize}
				Diese werden in den kommenden Abschnitten näher betrachtet.

				\subsubsection{Stirnradgetriebe}
					Ein \emph{Stirnradgetriebe} besteht aus ein oder mehreren Paarungen von Zahnrädern, wobei das erste Zahnrad direkt auf der Motorwelle moniert ist. Diese Getriebe sind preisgünstig und eignen sich für kleine Drehmomente.
				% end

				\subsubsection{Planetengetriebe}
					Ein \emph{Planetengetriebe} besteht aus einem zentralen \emph{Sonnenrad}, welches von mehreren \emph{Planetenrädern}, die auf einem Planetenradträger montiert sind, umkreist wird. Um diese liegt wiederum das \emph{Hohlrad}, welches mit allen Planetenrädern verzahnt wird. Das Getriebe hat drei Wellen (Sonnenrad, Planetenradträger, Hohlrad), wodurch sechs Übersetzungsmöglichkeiten existieren. Die üblichsten sind:
					\begin{enumerate}
						\item Sonnenrad angetrieben, Hohlrad festgehalten, Planetenradträger als (langsamere) Abtriebswelle
						\item Sonnenrad angetrieben, Planetenradträger festgehalten, Hohlrad als (langsamere) Abtriebswelle (rückwärts)
						\item Hohlrad angetrieben, Sonnenrad festgehalten, Planetenrad als (langsamere) Abtriebswelle
						\item Sonnenrad und Hohlrad mit gleicher Drehzahl angetrieben, Planetenradträger als (gleich schnelle) Abtriebswelle
					\end{enumerate}
					
					\begin{figure}
						\centering
						\includegraphics[width = 0.9\textwidth]{epicyclicgear}
						\caption{Planetengetriebe mit Sonnenrad (gelb), Planetenrädern (blau), Planetenradträger (grün) sowie Hohlrad (rot). Das rechte Bild zeigt die relative Verschiebung von Sonnenrad und Planetenradträger, nachdem letzterer um \ang{45} rotiert wurde. Quelle:~\url{https://commons.wikimedia.org/wiki/File:Epicyclic_gear_ratios.png}}
					\end{figure}
				% end

				\subsubsection{Harmonic Drive Getriebe}
					Ein \emph{Harmonic Drive Getriebe} besteht aus:
					\begin{itemize}
						\item Elliptischer \emph{Wave Generator} \\ Elliptische Stahlscheibe mit zentrischer Nabe sowie aufgezogenem elliptisch Verformbaren Kugellager.
						\item \emph{Flexspline} \\ Zylindrische, verformbare Stahlbüchse mit Außenverzahnung.
						\item \emph{Circular Spline} \\ Zylindrischer Ring mit Innenverzahnung.
					\end{itemize}
				
					Dabei wir der elliptische Wave Generator angetrieben und verformt über das Kugellager den Flexspline. Dieser befinet sich gegenüber der großen Ellipsenachse mit dem Circular Spline im Eingriff. Drehen des Wave Generators führt zu einer Verlagerung der großen Ellipsenachse und damit zu einer Verlagerung  des Zahneingriffsbereichs von Flexspline und Circular Spline. Eine halbe Umdrehung des Wave Generators führt dann zu einer Relativbewegung zwischen Flexspline und Circular Spline um einen Zahn.
					
					\begin{itemize}
						\item \textbf{Vorteile:}
							\begin{itemize}
								\item Spielfreiheit (\dh es existiert kein Spiel).
								\item Sehr genaue Positionier- und Wiederholgenauigkeit
								\item Kompakte Bauweise.
								\item Hohe Drehmomentkapazität.
								\item Hoher Wirkungsgrad.
								\item Hohe Torsionssteifigkeit (\dh das Getriebe ist sehr resistent gegenüber Verformungen).
								\item Hohe Zuverlässigkeit und lange Lebensdauer.
							\end{itemize}
						\item \textbf{Nachteile:}
							\begin{itemize}
								\item Teuer.
								\item War bislang nicht beliebig klein realisierbar, neue Entwicklungen ermöglichen aber auch kleine Varianten.
							\end{itemize}
					\end{itemize}
				% end
			% end
		% end

		\section{Alternative und elastische Antriebskonzepte} % 6.30, 6.31, 6.32
			\todo{Content}

			\subsection{Beine} % 6.33, 6.34
				\todo{Content}
			% end

			\subsection{Neue Materialien} % 6.35, 6.36, 6.36, 6.37, 6.42
				\todo{Content}
			% end

			\subsection{Compliant Robot Actuation} % 6.38
				\todo{Content}
			% end

			\subsection{Elastische Antriebskonzepte} % 6.45
				Die Grundidee ist die Kombination elektrischer Antriebe mit mechanischer (potentiell verstellbarer) Elastizität.
				
				\begin{itemize}
					\item Seriell-Elastische Antriebe (SEA):
						\begin{itemize}
							\item \textbf{Stärken:}
								\begin{itemize}
									\item Energiespeicherung reduziert die benötigte Leistungsspitze des Motors und den Energieverbrauch.
									\item Die Entkopplung von Antrieb und Abtrieb liefert Stoßkompensation.
									\item Sicherheitspotential.
								\end{itemize}
							\item \textbf{Schwächen:}
								\begin{itemize}
									\item Erhöhte Masse des Antriebssystems.
									\item Erhöhte Komplexität der mechanischen Konstruktion.
									\item Erhöhte Komplexität der Regelung.
								\end{itemize}
						\end{itemize}
					\item Parallel-Elastische Antriebe (PAE):
						\begin{itemize}
							\item \textbf{Stärken:}
								\begin{itemize}
									\item Energiespeicherung reduziert die benötigte Leistungsspitze des Motors und den Energieverbrauch, allerdings potentiell auch das Motordrehmoment bei SPitzen.
								\end{itemize}
							\item \textbf{Schwächen:}
								\begin{itemize}
									\item Erhöhte Masse des Antriebssystems.
									\item Erhöhte Komplexität der mechanischen Konstruktion.
									\item Erhöhte Komplexität der Regelung.
								\end{itemize}
						\end{itemize}
				\end{itemize}

				\subsubsection{Variable Stiffness Actuator} % 6.46
					\todo{Content}
				% end

				\subsubsection{Variable Impedance Actuators} % 6.47, 6.48, 6.49, 6.50, 6.51
					\todo{Content}
				% end
			% end

			\subsection{Vom Muskel-Skelett-Apparat inspirierte Roboter} % 6.52, 6.53
				\todo{Content}
			% end
		% end
	% end

	\chapter{Sensoren}
		Ein \emph{Sensor} ist ein technisches System, welches eine physikalische (analoge) Größe (\zB Position) und gegebenenfalls deren Änderung (\zB Geschwindigkeit) in geeignete (unsicherheitsbehaftete) elektronische (digitale) Signale transformiert.
		
		Ein \emph{internen Sensor} ("proprioceptive sensor") erfasst dabei die Roboter-internen Zustände, wobei ein \emph{externer Sensor} ("exteroceptive sensor") Informationen über den Zustand der Umwelt sammelt.
	
		\section{Interne Sensoren}
			Interne Sensoren können grob in die Kategorien
			\begin{itemize}
				\item Positionssensoren
				\item Geschwindigkeitssensoren
				\item Beschleunigungssensoren
				\item Inertial Navigation System (INS)
				\item Kraft-Momenten-Sensoren
			\end{itemize}
			unterteilt werden.

			\subsection{Positionssensoren}
				\subsubsection{Potentiometer}
					Ein \emph{Potentiometer} besteht aus einem \emph{Widerstandselement} mit darüber verlaufender Spannung und einem gleitendem Kontakt (\emph{Wischer}, "wiper"), der sich Über das Widerstandselement bewegt. Dabei kann sich entweder der Wischer oder das Widerstandselement bewegen. Abbildung~\ref{fig:potentiometer} zeigt ein lineares und ein rotatorisches Potentiometer.
					
					Die Spannung im Kontakt ist dann abhängig von der Position auf dem Widerstandselement und damit proportional zur Gelenkposition, womit die Position gemessen werden kann. Die Genauigkeit liegt (unter der Voraussetzung einer stabilen Spannungsquelle) bei ca. \SI{0.5}{\percent}.
					
					\begin{figure}
						\centering
						\begin{tikzpicture}
							\node [minimum width = 0.8cm] (a) {+\si{\volt}};
							\node [minimum width = 0.8cm, below = 2 of a] (b) {\SI{0}{\volt}};
							
							\draw [fill = tud2b, color = tud2b] (a.south east) -- (b.north east) -- (b.north west) -- (a.south west) -- cycle;
							
							\path (a.east) to coordinate(c) (b.east);
							\node [right = 1.6 of c] (A) {\(\si{\volt}_\text{aus}\)};
							\coordinate [right = 0.1 of c] (B);
							\draw [->, color = tud7b, line width = 4pt, > = { Latex[length = 4mm] }] (A) -- (B);
						\end{tikzpicture}
						\hspace{1cm}
						\begin{tikzpicture}[xscale = 0.8, yscale = 0.8]
							\node at (0.65, 0.1) {+\si{\volt}};
							\node at (0.5, -0.9) {\SI{0}{\volt}};
							
							\draw [line width = 0.4cm, color = tud2b] (0, 0) arc (0:340:2cm);
							
							\draw [->, color = tud7b, line width = 4pt, > = { Latex[length = 4mm] }] (-2cm, 0) to node[above, color = black, yshift = -1pt]{\(\si{\volt}_\text{aus}\)} (-0.3cm, 0);
							
							\draw [fill = black] (-2cm, 0) circle (0.15cm);
						\end{tikzpicture}
						\caption{Lineares (links) und rotatorisches (rechts) Potentiometer mit Widerstandselement (blau) und Kontakt (orange).}
						\label{fig:potentiometer}
					\end{figure}
				% end

				\subsubsection{Optische Codierer}
					Auf einer Scheibe wird ein kodiertes Muster angebracht, welches den Strahl einer Lichtquelle periodisch unterbricht, wobei diese Quelle auf einen Photodetektor ausgerichtet ist. Durch Messung der Unterbrechung kann die Position gemessen werden. Dabei werden zwei Arten von optischen Kodierern unterschieden:
					\begin{itemize}
						\item Inkrementelle Codierer
						\item Absolute Codierer
					\end{itemize}

					\paragraph{Inkrementell}
						Die Empfangseinheit zählt die Inkremente (die durch die periodischen Unterbrechungen erzeugt werden) und zählt diese (daher der Name \emph{inkrementeller Codierer}). Daraus kann anschließend die Position berechnet werden. Einer großer Nachteil dieser Methode ist, dass die Startposition unbekannt ist, \dh der Zähler muss zunächst Kalibriert werden.
						
						Durch mehrspurige Codierer können durch die Verschiebung der Inkremente mehr Daten gemessen werden:
						\begin{itemize}
							\item 1-spuriger Codierer: Winkel
							\item 2-spuriger Codierer: Winkel und Richtung
							\item 3-spuriger Codierer: Winkel, Richtung, Anfang/Ende
						\end{itemize}
					% end

					\paragraph{Absolut}
						Im Gegensatz zum inkrementellen wird beim \emph{absoluten Codierer} jeder Achsenposition ein individuelles Wortmuster zugeteilt, welches anschließend gemessen wird. Dadurch ist ein direktes Ablesen der Gelenkposition möglich und somit keine Kalibrierung notwendig. Allerdings ist die Konstruktion sehr aufwendig.
						
						Mit dem Gray-Code unterscheidet sich der Code an jeder Stelle nur um ein Bit, wodurch große Fehler vermieden werden.
					% end
				% end

				\subsubsection{Resolver} % 6.63
					\todo{Content}
					
					Resolver sind robust, störungssicher und haben eine hohe Lebensdauer, weshalb sie oft bei Industrierobotern eingesetzt werden.
				% end
			% end

			\subsection{Geschwindigkeitssensoren}
				Geschwindigkeitssensoren lassen sich \bspw durch Differentiation und Filterung aus mit hoher Frequenz abgetasteten Positionswerten erstellen (\dh die Geschwindigkeit wird indirekt gemessen).
			% end

			\subsection{Beschleunigungssensoren (Silizium-Beschleunigungssensor)}
				In einem \emph{Silizium-Beschleunigungssensor} befindet sich eine träge Masse in einem "Siliziumbad", wobei Auslenkungen der Aufhängung die mechanischen Spannungen ändern, wodurch der piezoresistive Widerstandswert geändert wird. Dieser Wert ist messtechnisch erfassbar, wodurch Beschleunigungen erkannt werden können. Allerdings ist eine Erfassung von Richtung und Betrag der Gravitation nötig, um diese herausrechnen zu können. Durch die Verwendung von drei 1D-Sensoren lässt sich ein 3D-Beschleunigungssensor konstruieren (indem diese orthogonal zueinander angebracht werden).
			% end

			\subsection{Inertial Navigation System (INS)} % 6.67, 6.71
				Die Aufgabe eines \emph{Inertial Navigation Systems} (INS) ist die Bestimmung der Orientierung relativ zu einem Inertialsystem. Dazu lassen sich \bspw folgende Sensoren einsetzen:
				\begin{itemize}
					\item Kompass
					\item Lagesensor
						\begin{itemize}
							\item Hierbei wird eine elektrisch leitfähige Flüssigkeit in einem versiegeltem Glas mit drei Elektronen platziert.
							\item Eine Lageänderung verursacht eine ungleiche Flüssigkeitsverteilung und damit ungleiche Widerstände relativ zum Winkel.
							\item Daraus kann anschließend die Position berechnet werden.
						\end{itemize}
					\item Gyroskop (mechanisch oder mikromechanisch)
				\end{itemize}

				\subsubsection{Mechanisches Gyroskop}
					Ein \emph{Gyroskop} ist ein schnell rotierender, semi-kardanisch aufgehängter Kreisel. Durch die Erdrotation wird ein Drehmoment in Richtung des Medians verursacht, wodurch eine Richtungsanzeige möglich wird.
					
					Angewendet werden Gyroskope an vielen Stellen:
					\begin{itemize}
						\item Linienflugzeug (ca. \num{12} Gyroskope)
						\item Raumstation MIR (\num{11} Gyroskope zur Orientierungshaltung zur Sonne)
						\item Häufig werden 3D-Beschleunigungssensoren für die lineare Beschleunigung und Gyroskope für die 3D-Winkelgeschwindigkeiten verwendet. Die Integration über die Geschwindigkeiten ergibt die zurückgelegte Bewegung (\emph{Odometrie}). Durch Filtern der Messwerte können Fehler und Drifts kompensiert werden.
						\item Ein normales Flugzeug-Gyroskop hat pro Betriebsstunde einen Drift von ca. \SI{1.85}{\kilo\meter}, "High-End"-Gyroskope kommen auf einen Drift von weniger als \SI{0.1}{\percent} der zurückgelegten Distanz.
					\end{itemize}
				% end

				\subsubsection{Mikromechanische Gyroskope}
					Bei mikromechanischen Gyroskopen wird die Rotation durch schwingende, mechanische Elemente registriert. Sie werden \zB als "Stimmgabel" realisiert:
					\begin{itemize}
						\item Zwei Zinken mit unterschiedlichen, festen Schwingfrequenzen.
						\item Bei einer Rotation verursacht die Corioliskraft eine differentielle, sinusförmige Kraft orthogonal zur Hauptschwingung in jedem Zinken.
						\item Durch die differentielle Verbiegungen der Zinken oder die Torsionsschwingung am Stamm der Stimmgabel kann diese Kraft detektiert werden.
						\item Die Anregung der Resonanzfrequenz der Zinken kann elektrostatisch, elektromagnetisch oder piezoresistiv erfolgen
						\item Die durch die Corioliskraft verursachten Schwingungen können kapazitiv, piezoresistiv oder piezoelektrisch detektiert werden.
						\item Eine optische Detektion ist auch möglich, ist \iA allerdings sehr teuer.
					\end{itemize}
				% end
			% end

			\subsection{Kraft-Momenten-Sensoren}
				Zeil von \emph{Kraft-Momenten-Sensoren} ist die Messung der Kräfte und Momente zwischen Effektor und Objekt. Oft wird hierfür eine sogenannte \emph{Kraftmessdose} verwendet, die eine Kombination aus mehreren Messapparaturen darstellt. Typische Apparaturen sind hierbei:
				\begin{itemize}
					\item Dehnungsmessstreifen (DMS)
					\item Piezokristalle
					\item Optische Effekte
				\end{itemize}
				Die Dose wird dabei zwischen Effektor und Roboterhand und -fuß angebracht.
				
				Oft haben Kraft-Momenten-Sensoren eine Speichenradform, wobei auf den Speichen/Stegen Dehnungsmessstreifen angebracht sind. Wirkt eine Kraft auf die Dose, so ändert sich die Länge er Stege. Auf den Dehnungsmessstreifen ist eine dünne Metallfolie in Matrixform angebracht, die bei Änderung der Länge ihren Widerstand ändert. Durch Messung dieser Änderung kann die Krafteinwirkung gemessen werden.
			% end
		% end

		\section{Externe und intelligente Sensoren}
			Abbildung~\ref{fig:sensorsystem_structure} zeigt die typische Struktur eines (externen) Sensorsystems.
			
			\begin{figure}
				\centering
				\begin{tikzpicture}[->, every node/.style = { minimum width = 6cm, minimum height = 0.8cm, draw, rectangle }]
					\node [fill = tud2a] (a) {Umwelt};
					\node [fill = tud8a, below = 0.5 of a] (b) {Sensortechnologie};
					\node [fill = tud8a, below = 0.5 of b] (c) {Aufbereitung/Vorverarbeitung};
					\node [fill = tud8a, below = 0.5 of c] (d) {Verarbeitung/Auswertung};
					\node [fill = tud2a, below = 0.5 of d] (e) {Weltmodellierung/Steuerung/\dots};
					
					\draw (a) -- (b);
					\draw (b) -- (c);
					\draw (c) -- (d);
					\draw (d) -- (e);
				\end{tikzpicture}
				\caption{Typische Struktur eines Sensorsystems, wobei die blau hinterlegten Schritte (größtenteils) analog und die orange hinterlegten Schritte (größtenteils) digital ablaufen.}
				\label{fig:sensorsystem_structure}
			\end{figure}
		
			Externe Sensoren können grob in die Kategorien
			\begin{itemize}
				\item Taktile Sensoren
				\item Näherungssensoren
				\item Abstandssensoren
				\item Positionssensoren
				\item Visuelle Sensoren
			\end{itemize}
			unterteilt werden.

			\subsection{Abstandssensoren}
				\emph{Abstandssensoren} messen den Abstand zwischen dem Sensor und einem Gegenstand. Diese Sensoren sind geeignet zur Erfassung von geometrischen Umweltinformation. Außerdem haben sie eine größere Reichweite als Näherungssensoren.
				
				Es werden drei grundlegende Typen von Abstandssensoren unterschieden:
				\begin{itemize}
					\item Optisch (Nutzung von sichtbaren, elektromagnetischen Wellen)
					\item Radar (elektromagnetische Wellen mit sehr kurzen Längen)
					\item Akustisch (mechanische Wellen)
				\end{itemize}

				\subsubsection{Akustische Abstandssensoren}
					\emph{Schall} ist ein an Materie gebundener Energie- und Impulstransport, wobei eine \emph{Schallwelle} die wellenförmige Ausbreitung der periodischen Anregung eines Übertragungsmediums beschreibt. Der hörbare Schall liegt dabei zwischen \SI{16}{\hertz} und \SI{16}{\kilo\hertz}, wobei alles darunter als \emph{Infraschall} und alles darüber als \emph{Ultraschall} bezeichnet wird.
					
					In den 1980er und 1990er sind Ultraschallsensoren die wichtigsten Sensoren zur Erdfassung der Umwelt. Seit Ende der 1990 werden jedoch vermehrt Laserscanner kombiniert mit Farbkameras eingesetzt. Im Nahbereich sind Ultraschallsensoren jedoch auch noch heute nützlich (Kollisionsdetektion, \bzw -vermeidung), sowie in Bereichen wo weder Laserscanner noch Kameras einsetzbar sind (\zB in Gebäuden mit Rauch).

					\paragraph{Ultraschall}
						Die Messung von Abständen mittels Ultraschall heißt \emph{sonar} ("sound navigation and ranging"). In der Natur wird diese Art der Navigation häufig eingesetzt, \zB von Delfinen und Fledermäusen.
						
						Zur Erzeugung von Ultraschall wird eine schwingende Folie eingesetzt, die im Sende-Modus durch die elektrostatische Kraft, ausgelöst von einer geladenen Aluplatte, vibriert. Im Empfangs-Modus bewegt der Klangdruck die Folie, wodurch sich die Kapazität des Kondensators ändern (elektrostatisches Mikrofon).
						
						Im Normalbetrieb sendet ein Sensor \SI{1}{\milli\second} bis \SI{1.2}{\milli\second} langes "Zwitschern" pro \SI{200}{\milli\second}. Dieses Zwitschern wird aufgrund der unterschiedlichen Materialbeschaffenheit und deren unterschiedlichen Reflexionseigenschaften in unterschiedlichen Frequenzen gesendet.
					% end

					\paragraph{Messsituationen}
						\begin{itemize}
							\item Im Idealzustand ist die Achse der Schallkeule orthogonal zu einem flachen Objekt. In diesem Fall wird ein genauer Abstand gemessen.
							\item Befindet sich ein kleines Objekt vor der Wand, so wird der Abstand weiterhin genau gemessen, die Querposition ist jedoch ungenau.
							\item Steht der Sender rotiert zur Wand, so ist der gemessene Abstand vom Rand der Schallkeule zu kurz (Unterschätzung). Die Unsicherheit des Abstands ist eine Funktion des Rotationswinkels und des Keulenöffnungswinkels.
							\item Ist die Rotation größer als der Keulenöffnungswinkel, so ist die Wand unsicherbar.
							\item Eine Kante ist ebenfalls unsichtbar, solange die Ecke nicht ein wenig abgerundet ist.
							\item Mehrfachreflexionen (wie in einer Ecke) bewirkt eine Starke Überschätzung des Abstands.
						\end{itemize}
					% end

					\paragraph{Abhilfe der Schwierigkeiten}
						Bei nur einem Empfänger darf die Umweltszene nur ein Objekt innerhalb der Schallkeule enthalten der reflektierende Objektteil muss orthogonal zur Strahlrichtung stehen.
						
						Gebräuchliche Abhilfen sind die Verwendung von mehreren Ultraschallsensoren und algorithmische Verfahren wie Peilverfahren: Die Position wird aus den Laufzeitunterschieden, \zB mit Triangulationsverfahren (ähnlich wie bei GPS), berechnet.
					% end

					\paragraph{Natur}
						Fledermäuse haben sehr unterschiedliche Ultraschalle (enge Schallkeulen, weite Schallkeulen, Zwitschern mit fester/veränderlicher Frequenz, \dots). Der aktuelle Stand der Ultraschallerzeugung ist vergleichbar mit dem Ultraschall von Fledermäusen, allerdings liegen die technischen Fähigkeiten zur Verarbeitung noch weiter hinter jenen von Fledermäusen.
					% end
				% end

				\subsubsection{Optische Abstandssensoren}
					Der Aufbau von optischen Abstandssensoren besteht aus einem Emitter (LED, Laserdioden) und einem Empfänger (Fototransistor). Optische Sensoren liefern sehr genaue Entfernungsmessungen und sind stabil gegen viele Fremdeinflüsse.
					
					Es gibt verschiedene Messverfahren:
					\begin{itemize}
						\item Ermittlung der Flugzeit (Laufzeit)
						\item aktive Triangulation
						\item Interferometrie (Phasenverschiebung)
						\item Stereoskopie
					\end{itemize}

					\paragraph{Laufzeitermittlung}
						Bei der \emph{Laufzeitermittlung} wird die Hin- und Rücklaufzeit eines Impulses (\zB Lichtimpuls) gemessen. Wurde zwischen Aussenden und Empfangen die Zeit \( \Delta t \) gemessen, so berechnet sich die Entfernund \(d\) wie folgt:
						\begin{equation*}
							d = \frac{c \cdot \Delta t}{2}
						\end{equation*}
						Es muss die Hälfte genommen werden, da der Lichtstrahl zum Objekt hin und zurück verläuft.
						
						Typische Probleme sind die Absorption des Strahls vom Objekt, Wegreflexion (\zB bei einem Spiegel) sowie Mehrfachreflexion (wodurch der Weg verlängert wird).
					% end

					\paragraph{2D-Laserscanner}
						In einem \emph{Laserscanner} wird ein gepulster Laserstrahl, abgelenkt durch einen beweglichen Spiegel, ausgesandt. Durch diesen Drehspiegel wird die Umgebung fächerförmig abgetastet. Trifft der Impuls auf ein Objekt, so wird er reflektiert und die Entfernung kann mittels Laufzeitermittlung berechnet werden. Durch die Abfolge der empfangenen Impulse kann die Entfernung, Lage und Kontur eines Objekts berechnet werden.
						
						Bei der \emph{Kartografierung} werden alle gescannten Szenen (gescannt mit einem mobilen System) zu einer Karte zusammengefasst.
					% end
				% end
			% end

			\subsection{Visuelle Sensoren}
				\begin{itemize}
					\item Visuelle Wahrnehmung ("visual perception")
						\begin{itemize}
							\item Aufnahme und Verarbeitung von visuelle Reizen
							\item Auge und Gehirn extrahieren relevante Informationen
							\item Erkennen von Elementen und deren Interpretation und Abgleich mit Erinnerungen
						\end{itemize}
					\item Maschinelles Sehen ("machine vision")
						\begin{itemize}
							\item Digitale Bildverarbeitung und Mustererkennung
							\item Eingesetzt \zB bei Prüfverfahren in der industriellen Fertigung
						\end{itemize}
					\item Bildverstehen ("computer vision")
						\begin{itemize}
							\item Extraktion komplexer Interpretationen und Schlüsse aus 2D-Abbildungen realer 3D-Szenen
							\item Viele langfristig orientierte Grundlagenforschungsfragen
						\end{itemize}
					\item Robotersehen ("robot vision")
						\begin{itemize}
							\item Maschinelles Sehen und Bildverstehen unter den Echtzeitbedingungen eines Roboters
							\item Begrenze Rechenleistung und schnelle Reaktionszeiten
						\end{itemize}
				\end{itemize}
			
				Voraussetzungen für maschinelles Sehen sind:
				\begin{enumerate}
					\item "Technisches Auge", \dh ein Kamerachip mit Optik
					\item "Intelligente", bildverarbeitende Algorithmen
					\item Ausreichende Strukturierung (Material, Merkmale der relevanten Objekte, \dots) der Szene
					\item Ausreichende Beleuchtung (Helligkeit, Lampen-Lichtspektrum, Reflexionen, \dots) der Szene
				\end{enumerate}
				Je nach Aufgabe ist eine Abstimmung dieser vier Voraussetzungen nötig, \dh es gibt keine allgemeine Lösung.
				
				Die klassische Hierarchie der Bildverarbeitungsoperationen ist in Abbildung~\ref{fig:image_processing_hierarchy} aufgezeigt.
				
				\begin{figure}
					\centering
					\begin{tikzpicture}[block/.style = { draw, rectangle, minimum height = 0.8cm, align = center }, minwidth/.style = { minimum width = 7cm }]
						\node [block, minimum width = 2cm] (a) {Szene};
						\node [block, minwidth, below = 0.5 of a] (b) {\textbf{Bilderzeugung}};
						\node [block, minwidth, below = 0.5 of b] (c) {\textbf{Bildvorverarbeitung} \\ Rauschunterdrückung};
						\node [block, minwidth, below = 0.5 of c] (d) {\textbf{Bildverarbeitung} \\ Segmentierung (Partitionierung)};
						\node [block, minwidth, below = 0.5 of d] (e) {\textbf{Bildbeschreibung} \\ Merkmalsextraktionen: \\ räumlich (Größe, Form) oder spektral};
						\node [block, minwidth, below = 0.5 of e] (f) {\textbf{Objekterkennung}};
						\node [block, minwidth, below = 0.5 of f] (g) {\textbf{Bildanalyse} \\ Interpretation der Szene \\ durch symbolische Beschreibung};
						\coordinate [below = 0.5 of g.south east] (h);
						
						\node [left = 0 of b] {Pixel};
						\node [left = 0 of d] {Kanten};
						\node [left = 0 of e] {Konturen};
						\node [left = 0 of f] {Objekte};
						\node [left = 0 of g] {Semantik};
						
						\path (b.south east) to coordinate(B) (c.north east);
						\path (c.south east) to coordinate(C) (d.north east);
						\path (d.south east) to coordinate(D) (e.north east);
						\path (e.south east) to coordinate(E) (f.north east);
						\path (g.south east) to coordinate(G) (h.north east);
						
						\node [right = 0 of B] {Rohbild (degradiert)};
						\node [right = 0 of C] {Fertigbild (korrigiert)};
						\node [right = 0 of D] {Segmentiertes Bild};
						\node [right = 0 of E] {Merkmale, \ggf auch 3D};
						\node [right = 0 of G] {Relevante Aussage};
						
						\draw [->] (a) -- (b);
						\draw [->] (b) -- (c);
						\draw [->] (c) -- (d);
						\draw [->] (d) -- (e);
						\draw [->] (e) -- (f);
						\draw [->] (f) -- (g);
					\end{tikzpicture}
					\caption{Klassische Hierarchie der Bildverarbeitung. Dabei findet alles bis zur Bildverarbeitung numerisch und alles ab der Bildbeschreibung symbolisch statt.}
					\label{fig:image_processing_hierarchy}
				\end{figure}

				\subsubsection{Bilderzeugung}
					Die \emph{Kameramatrix} beschreibt die Projektionsabbildung von 3D-Punkten durch eine Lochkamera auf 2D-Punkte der Bildebene. Dadurch können spezifische Verzerrungseffekte der Kameralinse berücksichtigt werden.
					
					Zur Bilderzeugung gibt es mehrere grundlegende Methoden von Bildwandlersystemen (Kamerachip):
					\begin{itemize}
						\item Binäre fotoelektrische Zellen \\ Der Chip besteht aus einzelnen Fotodioden, wobei die Bildpunkte entweder \num{1} oder \num{0} wahrnehmen (hell oder dunkel).
						\item Zeilen von Fotodioden (Linearkamera) \\ Die fotoelektrischen Zellen sind entlang einer Geraden angeordnet.
						\item Felder von Fotoelementen (Matrixkamera) \\ Die Zellen sind zweidimensional Angeordnet.
						\item CCD-Fernsehkameras \\ Fernsehnorm, vorgeschaltete Kameraoptik, \dots
					\end{itemize}
				% end

				\subsubsection{Grundlagen}
					Die \emph{Lichtintensitätsfunktion} \( f^\ast \), die für einen Pixel \( (x, y) \) die Lichtintensität \( [f^\ast] = \si{\candela} \) angibt, kann in ein Produkt
					\begin{equation*}
						f^\ast(x, y) = i(x, y) \cdot r(x, y)
					\end{equation*}
					aufgespalten werden mit der Illuminationsfunktion \( i(x, y) \) und der Reflexionsfunktion \( 0 < r(x, y) < 1 \). Dabei hat die Illuminationsfunktion die Einheit \( [i] = \si{\candela} \) (Candela) und die Reflexion ist einheitenlos. Beispielhafte Werte für die Illumination \(i\) und die Reflexion \(r\) sind in den Tabellen~\ref{tab:example_illumination} und~\ref{tab:example_reflexion} gegeben.
					
					Die Absorptionsfunktion
					\begin{equation*}
						a(x, y) \coloneqq 1 - r(x, y)
					\end{equation*}
					beschreibt, wie viel Licht an einem Pixel \( (x, y) \) absorbiert wird/wurde.
					
					\begin{table}
						\centering
						\begin{tabular}{l|l}
							Ort          & Illumination \(i\)   \\ \hline
							Sonne        & \SI{10000}{\candela} \\
							Wolken       & \SI{1000}{\candela}  \\
							Arbeitsplatz & \SI{100}{\candela}
						\end{tabular}
						\caption{Beispielhafte Werte der Illumination \(i\).}
						\label{tab:example_illumination}
					\end{table}
					\begin{table}
						\centering
						\begin{tabular}{l|l}
							Material       & Reflexion \(r\) \\ \hline
							Schwarzer Samt & \num{0.01}      \\
							Edelstahl      & \num{0.65}      \\
							Weiße Wand     & \num{0.80}      \\
							Spiegel        & \num{0.90}      \\
							Schnee         & \num{0.93}
						\end{tabular}
						\caption{Beispielhafte Werte der Reflexion \(r\).}
						\label{tab:example_reflexion}
					\end{table}
				
					Zusammengefasst ergibt sich die \emph{Bildmatrix} \( f = (f_{i, j}) \)
					\begin{equation*}
						f =
							\begin{bmatrix}
								f_{0, 0}     & f_{0, 1}     & \cdots & f_{0, N - 1}     \\
								\vdots       & \vdots       & \ddots & \vdots           \\
								f_{M - 1, 0} & f_{M - 1, 1} & \cdots & f_{M - 1, N - 1}
							\end{bmatrix}
					\end{equation*}
					mit den Elementen als Werten der Lichtintensitätsfunktion. Typische Formate \( M \times N \) sind
					\begin{itemize}
						\item PAL:  \tabto{1.5cm} \( N = \num{768} \),  \tabto{3.5cm} \( M = \num{576} \)  \tabto{5.5cm} (576i50)
						\item NTSC: \tabto{1.5cm} \( N = \num{640} \),  \tabto{3.5cm} \( M = \num{480} \)  \tabto{5.5cm} (480i60)
						\item HDTV: \tabto{1.5cm} \( N = \num{1280} \), \tabto{3.5cm} \( M = \num{720} \)  \tabto{5.5cm} (720p50, WXGA)
						\item HDTV: \tabto{1.5cm} \( N = \num{1920} \), \tabto{3.5cm} \( M = \num{1080} \) \tabto{5.5cm} (1080i50, Full HD)
					\end{itemize}
					Bei einer monochromen Kamera wird pro Bild eine Matrix verwendet, bei einer polychromen Kamera drei Matrizen. Für diese drei Matrizen können unterschiedliche Farbmodelle verwendet werden, z.\,B.:
					\begin{itemize}
						\item RGB (Red, Green, Blue) \\ Speziell für Monitore relevant, da diese meistens die drei Farben Rot, Grün und Blau anzeigen können.
						\item HSI/HSV (Hue, Saturation, Intensity/Value) \\ Speziell für die Bildverarbeitung, da Segmentierung leicht ist.
					\end{itemize}
					Das RGB-Farbmodell mit \num{8} Bit je Farbe hat damit \( \num{256} \cdot \num{256} \cdot \num{256} = \num{16777216}\text{ mögliche Farben} \).
					
					Eine alternative zum RGB-Modell ist das HSI/HSV-Modell, welches aus den Komponenten
					\begin{itemize}
						\item Hue (Farbwellenlänge)
						\item Saturation (Sättigung, Reinheit der Farbe)
						\item Intensity/Value (Intensität, Helligkeit)
					\end{itemize}
					besteht. Das RGB-Modell mit den Anteilen \(R\), \(G\) und \(B\) lässt sich wie folgt in das HSI/HSV-Modell umrechnen:
					\begin{align*}
						\cos H & = \frac{2R - G - B}{2\sqrt{(R - G)^2 + (R - B)(G - B)}} \\
						S      & = 1 - \frac{3}{R + G + B} \min \{\, R, G, B \,\}        \\
						V = I  & = \frac{1}{3} (R + G + B)
					\end{align*}
					Ein Vorteil des HSI/HSV-Modells ist, dass die Farbmanipulation sehr ähnlich zur menschlichen Wahrnehmung ist.
				% end

				\subsubsection{Bildvorverarbeitung}
					Es gibt zwei Klassen von \emph{Bildvorverarbeitungsverfahren}:
					\begin{enumerate}
						\item \emph{Ortsbereichsverfahren}
							\begin{itemize}
								\item Die Manipulation findet direkt auf der Pixelebene statt.
								\item Die allgemeine Berechnungsformel lautet \( \vec{g}(x, y) = \vec{h}\big(\vec{f}(x, y)\big) \), wobei \(\vec{g}\) die neuen und \(\vec{f}\) die alten Bildintensitäten darstellt. \(\vec{h}\) ist ein Operator, der die Intensität transformiert (\bspw durch Nachbarschaftsbeziehungen).
								\item Aufgrund der geringen Rechenzeit vor allem für Roboter relevant (aufgrund der Echtzeitanforderungen).
							\end{itemize}
						\item \emph{Frequenzbereichsverfahren}
							\begin{itemize}
								\item Es wird zunächst eine Bildtransformation (diskrete Fouriertransformation, Wavelets, \dots) in den Frequenzraum durchgeführt.
								\item Anschließend wird ein Verfahren im Frequenzraum angewandt und das Bild anschließend zurück transformiert.
								\item Wird \bspw bei der Offline-Auswertung von Satellitenbildern eingesetzt.
								\item Aufgrund der hohen Rechenzeit werden diese Verfahren in der Robotik selten eingesetzt.
							\end{itemize}
					\end{enumerate}

					\paragraph{Nachbarschaftsbildverarbeitung}
						Mit der \( n \times n \)-Nachbarschaft eines Pixels \( (x, y) \) wird die Matrix (\bzw die Pixel)
						\begin{equation*}
							\begin{bmatrix}
								(x - \lfloor n/2 \rfloor, y - \lfloor n/2 \rfloor) & \cdots & (x - \lfloor n/2 \rfloor, y) & \cdots & (x - \lfloor n/2 \rfloor, y + \lfloor n/2 \rfloor) \\
								\vdots                                             & \ddots & \vdots                       & \ddots & \vdots                                             \\
								(x, y - \lfloor n/2 \rfloor)                       & \cdots & (x, y)                       & \cdots & (x, y + \lfloor n/2 \rfloor)                       \\
								\vdots                                             & \ddots & \vdots                       & \ddots & \vdots                                             \\
								(x + \lfloor n/2 \rfloor, y - \lfloor n/2 \rfloor) & \cdots & (x - \lfloor n/2 \rfloor, y) & \cdots & (x + \lfloor n/2 \rfloor, y + \lfloor n/2 \rfloor)
							\end{bmatrix}
						\end{equation*}
						bezeichnet, wobei die \(y\)-Achse von links nach rechts und die \(x\)-Achse von oben nach unten wächst. Dies ergibt beispielhaft für die \( 3 \times 3 \)-Nachbarschaft von \( (x, y) \):
						\begin{equation*}
							\begin{bmatrix}
								(x - 1, y - 1) & (x - 1, y) & (x - 1, y + 1) \\
								(x, y - 1)     & (x, y)     & (x, y + 1)     \\
								(x + 1, y - 1) & (x + 1, y) & (x + 1, y + 1)
							\end{bmatrix}
						\end{equation*}
						
						In der \emph{Nachbarschaftsbildverarbeitung} wird nun ein solcher Bildausschnitt bezüglich eines Pixels \( (x, y) \) betrachtet und \zB mittels \emph{Nachbarschaftsdurchschnittsbildung} eine neue Intensität des Pixels berechnet. Der folgende Teil beschränkt sich auf \( 3 \times 3 \)-Nachbarschaften, theoretisch sind alle Verfahren aber auch mit größeren Nachbarschaften möglich.
						
						Bei der Nachbarschaftsdurchschnittsbildung wird jeder Pixels eines Bildausschnitts
						\begin{equation*}
							\begin{bmatrix}
								f_1 & f_2 & f_3 \\
								f_4 & f_5 & f_6 \\
								f_7 & f_8 & f_9
							\end{bmatrix}
						\end{equation*}
						mit einem Gewicht \( \omega_1, \cdots, \omega_9 \) (wobei \( \sum_{k = 1}^{9} \omega_k = 1 \) gelten muss) multipliziert, was sogenannte \emph{Gewichtsmaske} darstellt. Diese wird häufig auch durch eine Matrix
						\begin{equation*}
							\mat{\omega} =
								\begin{bmatrix}
									\omega_1 & \omega_2 & \omega_3 \\
									\omega_4 & \omega_5 & \omega_6 \\
									\omega_7 & \omega_8 & \omega_9
								\end{bmatrix}
						\end{equation*}
						dargestellt. Die neue Intensität \( g_5 \) des zentralen Pixels wird dann durch
						\begin{equation*}
							g_5 = \sum_{k = 1}^{9} \omega_k f_k
						\end{equation*}
						oder Allgemein
						\begin{equation*}
							g = \sum_{k = 1}^{n^2} \omega_k f_k
						\end{equation*}
						berechnet.
						
						Beispiele für Nachbarschaftsfilter:
						\begin{itemize}
							\item Mittelwertbildung:
						\end{itemize}
						\begin{equation*}
							\mat{\omega} =
								\begin{bmatrix}
									1/9 & 1/9 & 1/9 \\
									1/9 & 1/9 & 1/9 \\
									1/9 & 1/9 & 1/9
								\end{bmatrix}
						\end{equation*}
						\begin{itemize}
							\item Detektion isolierter Ausreißer (\zB bei konstant weißem Hintergrund):
						\end{itemize}
						\begin{equation*}
							\mat{\omega} =
								\begin{bmatrix}
									-1 & -1 & -1 \\
									-1 &  8 & -1 \\
									-1 & -1 & -1
								\end{bmatrix}
						\end{equation*}
						
						Ein prinzipielles Problem bei Nachbarschaftsdurchschnittsbildung ist, dass scharfe Bilddetails (\zB Ecken und Kanten) unscharf werden. Eine Abhilfe ist, einen \emph{Median-Filter} zu verwenden. Dabei berechnet sich die neue Intensität \(g\) eines Pixels durch den Medianwert der Intensitäten der Nachbarschaft, \dh ist Intensitäten werden sortiert und es wird der mittlere Wert (der Median) als neue Intensität genutzt.
					% end
				% end

				\subsubsection{Bildverarbeitung}
					Die zentralen Bildverarbeitungsschritte sind \emph{Kantendetektion} (als Voraussetzung für viele Objekterkennungsalgorithmen) und \emph{Segmentierung} (die Zerlegung des Bildes in Komponenten ober Objekte). Dabei werden die zentralen Prinzipien der Unstetigkeiten (zur Kanten- und Konturerkennung) sowie Ähnlichkeit (Schwellwertverfahren, Bereichswachstum) verwendet.

					\paragraph{Kantendetektion}
						Bei der \emph{Kantendetektion} wird verwendet, dass starke, lokale Änderungen der Intensitätsfunktion häufig Projektionen von Kanten der Szene sind. Allerdings entsprechen nicht alle Änderungen der Intensität von tatsächlichen Objektbegrenzungen und nicht alle Begrenzungen führen zu einer starken Änderung der Intensität. Das allgemeine Vorgehen bei der Kantendetektion besteht aus zwei Schritten:
						\begin{enumerate}
							\item Extraktion von Kandidaten für Kantenelemente
							\item Kombination der Elemente zu längeren Strukturen
						\end{enumerate}
					
						Die allgemeine Idee ist, die Größe der ersten Ableitung zur Detektion von Kantenelementen und die Größe der zweiten Ableitung zur Interpretation der Lage der Pixel (negative zweite Ableitung \(\to\) Pixel liegt auf der dunklen, positive zweite Ableitung \(\to\) Pixel liegt auf der hellen Seite der Kante).
						
						Der Gradient einer kontinuierlichen Funktion, differenzierbaren Funktion \( f(x, y) \) ist
						\begin{equation*}
							\nabla f(x, y) =
								\begin{bmatrix}
									\frac{\partial f}{\partial x} \\
									\frac{\partial f}{\partial y}
								\end{bmatrix}
						\end{equation*}
						Problem: \( f(x, y) \), \(x\) und \(y\) stammen aus einem diskreten (ganzzahligen) Wertebereich. Daher muss der Gradient durch den Differenzenquotienten angenähert werden. Dabei können entweder die Vorwärtsdifferenzen
						\begin{equation*}
							\frac{\partial f}{\partial x} = \lim\limits_{h \to 0} \frac{f(x + h, y) - f(x, y)}{h} \approx f(x + 1, y) - f(x, y)
						\end{equation*}
						oder die zentrale Differenzen
						\begin{equation*}
							\frac{\partial f}{\partial x} = \lim\limits_{h \to 0} \frac{f(x + h, y) - f(x - h, y)}{2h} \approx \frac{1}{2} \big( f(x + 1, y) - f(x - 1, y) \big)
						\end{equation*}
						verwendet werden (analog für \( \partial f / \partial y \)). Aufgrund des Mittlungseffekts eignen sich die zentralen Differenzen hier mehr.

						\subparagraph{Prewitt-Operator} % 8.58, 8.59, 8.60, 8.61
							Der \emph{Prewitt-Operator} ist Zusammengesetz auf zwei Filtern: Das Prewitt-X Filter und das \emph{Prewitt-Y Filter}. Ersteres findet Kanten über die \(x\)-Achse, letzterer über die \(y\)-Achse. Diskretisiert ergeben sich folgende Gewichtsmasken:
							\begin{gather*}
								\begin{bmatrix}
									-1 & -1 & -1 \\
									0  & 0  & 0  \\
									1  & 1  & 1
								\end{bmatrix} \tag{Prewitt-X Filter} \\
								\begin{bmatrix}
									-1 & 0 & 1 \\
									-1 & 0 & 1 \\
									-1 & 0 & 1
								\end{bmatrix} \tag{Prewitt-Y Filter}
							\end{gather*}
							Daraus ergeben sich die gefilterten Bilder \(p_x\) (Prewitt-X Filter) und \(p_y\) (Prewitt-Y Filter).
							
							Zusammengesetzt ergibt sich der Prewitt-Operator (\bzw das Graustufenbild)
							\begin{equation*}
								M \approx \sqrt{p_x^2 + p_y^2}
							\end{equation*}
						% end

						\subparagraph{Andere Operatoren} % 8.62, 8.63
							Andere Operatoren zur Kantendetektion sind \bspw der Sobel-Operator und das Roberts-Filter. Zusammengefasst lauten diese:
							\begin{itemize}
								\item Prewitt-Operator:
							\end{itemize}
							\begin{equation*}
								M \approx \sqrt{p_x^2 + p_y^2} \quad\quad\quad\quad
								p_x = \begin{bmatrix}
									-1 & -1 & -1 \\
									0  & 0  & 0  \\
									1  & 1  & 1
								\end{bmatrix} \quad\quad\quad\quad
								p_y = \begin{bmatrix}
									-1 & 0 & 1 \\
									-1 & 0 & 1 \\
									-1 & 0 & 1
								\end{bmatrix}
							\end{equation*}
							\begin{itemize}
								\item Sobel-Operator:
							\end{itemize}
							\begin{equation*}
								M \approx \sqrt{p_x^2 + p_y^2} \quad\quad\quad\quad
								p_x = \begin{bmatrix}
									-1 & -2 & -1 \\
									0  & 0  & 0  \\
									1  & 2  & 1
								\end{bmatrix} \quad\quad\quad\quad
								p_y = \begin{bmatrix}
									-1 & 0 & 1 \\
									-2 & 0 & 2 \\
									-1 & 0 & 1
								\end{bmatrix}
							\end{equation*}
							\begin{itemize}
								\item Roberts-Filter:
							\end{itemize}
							\begin{equation*}
								R = \lvert r_x \rvert + \lvert r_y \rvert \quad\quad\quad\quad
								r_x = \begin{bmatrix}
									-1 & 0 \\
									0  & 1
								\end{bmatrix} \quad\quad\quad\quad
								r_y = \begin{bmatrix}
									0 & -1 \\
									1 & 0
								\end{bmatrix}
							\end{equation*}
						% end
					% end

					\paragraph{Konturerkennung}
						\subparagraph{Lokale Analyse}
							Es wird die lokale Nachbarschaft eines Pixels \( (x, y) \) untersucht. Außerdem werden regelbasierte Verbindungen von Kandidaten für Kantenelemente durchgeführt:
							\begin{itemize}
								\item Wenn \( \big\lvert \nabla f(x, y) - \nabla f(\tilde{x}, \tilde{y}) \big\rvert \leq T \), \( T > 0 \) (die Gradienten sind Betragsmäßig ähnlich) \\ und \( \big\lvert \alpha(x, y) - \alpha(\tilde{x}, \tilde{y}) \big\rvert < A \), \( A > 0 \) (die Winkel der Gradientenvektoren sind ähnlich), dann:
								\item Verbinde \( (x, y) \) mit \( (\tilde{x}, \tilde{y}) \) und kennzeichne diese Verbindung (\zB durch einen bestimmten Grauwert/eine bestimme Farbe oder ein Symbol).
							\end{itemize}
							Dabei ist
							\begin{equation*}
								\alpha(x, y) \coloneqq \arctan \frac{\partial f / \partial y}{\partial f / \partial x}
							\end{equation*}
							der Winkel des Gradientenvektors.
						% end

						\subparagraph{Globale Analyse und Hough-Transformation}
							Die globale Analyse geschieht durch eine sogenannte \emph{Hough-Transformation}. Dabei werden mehrere Punkte verbunden, sofern diese auf einer vorgegebenen Kurve (\zB eine Gerade oder eine Parabel) liegen. Im folgende wird Beispielhaft die Hough-Transformation \bzgl einer Geraden betrachtet, prinzipiell kann sie aber für jede durch eine Gleichung
							\begin{equation*}
								g(x, y, c_1, c_2, c_3) = 0
							\end{equation*}
							gegebene Kurve durchgeführt werden (\zB für einen Kreis \( (x - c_1)^2 + (y - c_2)^2 - c_3^2 = 0 \) mit Radius \( c_3 \)).
							
							Liegen Punkte \( (x_i, y_i) \) auf einer Geraden, so erfüllen diese die Gleichung \( y_i = ax_i + b \) mit den Parametern \(a, b\). Diese Gleichung kann mit
							\begin{equation*}
								y_i = ax_i + b \quad\iff\quad b = -x_ia + y_i
							\end{equation*}
							zu einer Geradengleichung im Parameterraum \( (a, b) \) umgeformt werden. Bei der Hough-Transformation wird nun jeder Punkt \( (x_i, y_i) \) einer Geraden in der \( (a, b) \)-Ebene zugeordnet. Liegen zwei Punkte \( (x_i, y_i) \) und \( (x_j, y_j) \) auf einer Geraden, so schneiden sich die Hough-Transformierten in einem Punkt. Dieser Schnittpunkt \( (a^\ast, b^\ast) \) entspricht den Parameter der Geraden, auf der die zwei Punkte liegen, \dh es gilt:
							\begin{equation*}
								y_i = a^\ast x_i + b^\ast \quad\quad\text{und}\quad\quad y_j = a^\ast x_j + b^\ast
							\end{equation*}
							Schneiden sich drei Graden in einem Punkt, so liegen alle entsprechenden Punkte auf einer Geraden.
							
							In der Praxis ist die Darstellung \( y = ax + b \) der Geraden problematisch, da vertikale Geraden nicht dargestellt werden. Es wird daher eher die Parametrisierung \( x \cos\theta + y \sin\theta = \rho \) verwendet, da hier das Problem nicht auftritt.
							
							% TODO: Hough-Transformation: Beispiel.
						% end
					% end

					\paragraph{Segmentierung}
						Ziel der \emph{Segmentierung} ist, das Bild \(B\) ein flächige \emph{Zusammenhangkomponenten} \( S_1, \cdots, S_n \) zu zerlegen, wobei diese paarweise disjunkt sind und \( S_1 \cup \cdots \cup S_n = B \) gilt. Dazu müssen die Grenzen von Objektflächen gefunden werden, die für die weitere Interpretation von Bedeutung sind.

						\subparagraph{Schwellwertabfrage}
							Dieses Verfahren wird häufig verwendet und ist insbesondere im HSI/HSV-Farbraum sehr nützlich. Bezogen auf die Intensität \( f(x, y) \) werden zwei Schwellwerte \( \tau_1, \tau_2 \) festgelegt, wodurch sich über
							\begin{equation*}
								g(x, y) \coloneqq
									\begin{cases*}
										0 & \text{falls } \( f(x, y) < \tau_1 \) \\
										1 & \text{falls } \( \tau_1 < f(x, y) < \tau_2 \) \\
										2 & \text{falls } \( \tau_2 < f(x, y) \)
									\end{cases*}
							\end{equation*}
							ein trinäres Schwellwertbild ergibt.
							
							Dieses Verfahren wirft allerdings Probleme auf, da die Intensitätsfunktion stark von der aktuellen Beleuchtung abhängig ist, welche von Bild zu Bild variieren kann. Eine automatische Adaption der Schwellwerte erfordert eine robuste Minimum-Suche, wobei die Minima abhängig sind von Beleuchtung, Lager der Objekte, \dots.
						% end

						\subparagraph{Bereichswachstum}
							\begin{itemize}
								\item Es wird mit einem oder mehreren geeigneten "Saat"-Punkten ("seed points") gestartet und die direkten Nachbarpixel überprüft.
								\item Ein untersuchter Pixel wird zu dem Bereich des Startpixels hinzugefügt, wenn dieser dem Startpixel ähnlich ist (\zB gleicher Grauwert, Farbe, Textur, \dots).
								\item Unterscheidet sich der Pixel stark, so wird ein neuer Bereich eröffnet.
								\item Anschließend wird das Bild rekursiv weiter untersucht.
								\item Weitere Operationen können \zB das Aufteilen und Verbindungen von Bereichen sein.
							\end{itemize}
						% end
					% end
				% end

				\subsubsection{Merkmalsextraktion}
					Bisher wurden Objekte Bildhaft durch diskrete Bildfunktionen beschrieben. Die \emph{Merkmalsextraktion} beschäftigt sich nun mit der Charakterisierung von Objekten durch einen Vektor von Merkmalen sowie eventuell Beziehungen zwischen Objekten (Relationstupel) wie Nachbarschaft und Größe. Ausgangspunkt ist dabei das durch Segmentierung und Bildvorverarbeitung entstandene Binärbild \( g(x, y) \). Ziel ist die Extraktion der Merkmale, die ein Segment beschreiben.
					
					Merkmale können \zB sein:
					\begin{itemize}
						\item \(m_1\): Objektumfang \( m_1 = \int_\text{Kontur} \! g(x, y) \dif{s} \approx \sum_\text{Kontur} g(x, y) \)
						\item \(m_2\): Objektfläche \( m_2 = \iint \! g(x, y) \dif{x} \dif{y} \approx \sum_x \sum_y g(x, y) \)
						\item \(m_3\): Anzahl der "Löcher"
						\item \(m_4\): Farbe
						\item \dots
					\end{itemize}
					Solche Merkmale sollten möglichst (weitgehend)
					\begin{itemize}
						\item invariant gegen Skalierung, Rotation sowie Translation,
						\item robust (gegen Rauschen), signifikant, diskriminierend (unterscheidbar) sowie
						\item schnell berechenbar sein.
					\end{itemize}
				% end

				\subsubsection{Objektklassifikation}
					\begin{itemize}
						\item Klassische Ansätze zur Objektklassifikation:
							\begin{itemize}
								\item Bildvergleich im Merkmalsraum
								\item Template Matching
							\end{itemize}
						\item In den letzten Jahren wurden große Fortschritte durch Deep Learning erzielt.
						\item Deep Learning Systeme scheitern allerdings noch an einem echten Verstehen der Objekte.
					\end{itemize}
				% end
				
				\subsubsection{Bildverstehen} % 8.87, 8.88, 8.89, 8.90, 8.91, 8.92
					\todo{Content}
				% end
			% end

			\subsection{3D-Sensoren und Perzeption}
				Bei einem einzelnen RGB-Pixel eines 2D-Farbbildes fließen viele Faktoren ein:
				\begin{itemize}
					\item Lichtquelle (Anzahl, Helligkeit, Farbspektrum)
					\item Objekte (Farbe, physikalische Eigenschaften wie Transparenz und Reflexion)
					\item Szene (Schattenwurf)
					\item Projektion (Perspektivische Verzerrung)
					\item Sensorqualität
				\end{itemize}
				Ein Mensch ist extrem gut darin, aus einem einzelnen Bild Tiefeninformationen zu extrahieren, wobei dies im Bereich Computer Vision noch immer eine große Herausforderung ist.
				
				Werden zwei Farbbilder (leicht versetzt) verwendet, so wird dies als \emph{Stereo Vision} (oder in der Biologie auch "binokulares Sehen") bezeichnet. Dies erlaubt eine passive Tiefenschätzung. Andere Spezies wie Fledermäuse haben sogar eine aktive Tiefenschätzung (Sonar).
				
				Distanzinformationen sind extrem wichtig:
				\begin{itemize}
					\item 3D-Navigation
					\item Interaktion
					\item Kollisionsvermeidung
					\item Objekterkennung
					\item Gestenerkennung
					\item Virtual/Augmented Reality
					\item \dots
				\end{itemize}

				\subsubsection{Bildbasierte 3D-Sensoren}
					\paragraph{Stereo Vision}
						\emph{Stereo Vision} basiert auf der Triangulation von Bildpunkten durch die Verwendung von zwei Bildern.
						
						Basierend auf Abbildung~\ref{fig:stereo_triangulation} kann die Distanz \(Z\) wie folgt berechnet werden:
						\begin{equation*}
							\frac{Z - f}{B - (x - x')} = \frac{Z}{B} \quad\iff\quad BZ - Bf = BZ - Z(x - x') \quad\iff\quad Z = \frac{Bf}{x - x'}
						\end{equation*}
						
						\begin{figure}
							\centering
							\begin{tikzpicture}
								\node [fill = black, draw, circle, label = above:{\(X\)}] (X) at (0, 0) {};
								\node [fill = black, draw, circle] (x) at (-3, -6) {};
								\node [fill = black, draw, circle] (xPrime) at (3, -6) {};
								\node [fill = black, draw, circle, label = below:{\(O\)}] (o) at (-4, -8) {};
								\node [fill = black, draw, circle, label = below:{\(O'\)}] (oPrime) at (4, -8) {};
								
								\path let \p1 = (o), \p2 = (x) in coordinate (f) at (\x1, \y2);
								\path let \p1 = (oPrime), \p2 = (xPrime) in coordinate (fPrime) at (\x1, \y2);

								\coordinate [above = 0.1 of x] (xShift);
								\coordinate [above = 0.1 of xPrime] (xPrimeShift);
								
								\path let \p1 = (xShift), \p2 = (f) in coordinate (fShift) at (\x2, \y1);
								\path let \p1 = (xPrimeShift), \p2 = (fPrime) in coordinate (fPrimeShift) at (\x2, \y1);
								
								\coordinate [left = 2 of x] (xShiftLeft);
								\coordinate [right = 0.2 of x] (xShiftRight);
								\coordinate [left = 0.2 of xPrime] (xPrimeShiftLeft);
								\coordinate [right = 2 of xPrime] (xPrimeShiftRight);
								
								\path (o) to coordinate(oCenter) (oPrime);
								
								\draw (o) to node[below]{Baseline \(B\)} (oPrime);
								\draw [->] (o) to node[left]{\(f\)} (f);
								\draw [->] (oPrime) to node[left]{\(f\)} (fPrime);
								\draw [->] (fShift) to node[above]{\(x\)} (xShift);
								\draw [->] (fPrimeShift) to node[above]{\(x'\)} (xPrimeShift);
								\draw (xShiftLeft) to (xShiftRight);
								\draw (xPrimeShiftRight) to (xPrimeShiftLeft);
								\draw (o) to (X);
								\draw (oPrime) to (X);
								\draw [->] (oCenter) to node[right]{\(Z\)} (X);
							\end{tikzpicture}
							\caption{Triangulation der Distanz \(Z\) eines Objekts \(X\) durch zwei Kameras \(O\) und \(O'\).}
							\label{fig:stereo_triangulation}
						\end{figure}
					
						Diese Art der Berechnung wirft das Problem auf, dass detektiert werden muss, welche Pixel das selbe Objekt abbilden.
						
						\begin{itemize}
							\item \textbf{Vorteile:}
								\begin{itemize}
									\item Nur zwei Kameras nötig.
									\item Entspricht dem menschlichen Vorbild (binokulares Sehen).
									\item Farbinformationen sind für jeden Punkt verfügbar.
									\item Hohe Bildraten möglich.
								\end{itemize}
							\item \textbf{Nachteile:}
								\begin{itemize}
									\item Benötigt komplizierte Algorithmen, um die Pixel zuzuordnen.
									\item Erfordert viel CPU Leistung.
									\item Angewiesen auf texturierte Oberflächen (zur Pixelzuordnung).
									\item Sensitiv gegenüber Hintergrundbeleuchtung.
								\end{itemize}
						\end{itemize}
					% end

					\paragraph{Structured Light Kamera} % 8.107, 8.108, 8.109, 8.110, 8.111, 8.112, 8.113, 8.114
						\todo{Content}
					% end

					\paragraph{Stereo Vision + Structured Light} % 8.115, 8.116, 8.117
						\todo{Content}
					% end

					\paragraph{Time-of-Flight (ToF) Kamera}
						Eine \emph{Time-of-Flight} (ToF) Kamera sendet Lichtimpulse (meist Infrarot) und misst die Reflexionen. Hierzu gibt es drei grundlegende Techniken:
						\begin{itemize}
							\item Direct Time-of-Flight Imagers/Flash Lidar
								\begin{itemize}
									\item Direkte Zeitmessung der Lichtstrecke
									\item Benötigt starke Signalflanken (\zB Laserdioden)
								\end{itemize}
							\item Carrier Wave Modulation (Phasenvergleichsverfahren)
								\begin{itemize}
									\item Es wird die Phasenverschiebung des reflektierten Lichtsignals gemessen.
								\end{itemize}
							\item Ranged Gated Imagers ("Shutter")
								\begin{itemize}
									\item Er Shutter öffnet sich in der gleichen Frequenz, in der die Lichtimpulse ausgesendet werden.
									\item Ein reflektierter Impuls wird teilweise vom Shutter blockiert, was einen Rückschluss auf die zurückgelegte Lichtstrecke zulässt.
								\end{itemize}
						\end{itemize}
					
						\begin{itemize}
							\item \textbf{Vorteile:}
								\begin{itemize}
									\item Hohe Bildrate (bis zu \num{160} FPS üblich), daher geeignet für Echtzeitanwendungen
									\item Sehr wenig CPU Leistung nötig.
									\item Musterunabhängig, \dh es werden keine strukturierten/texturierten Oberflächen benötigt.
								\end{itemize}
							\item \textbf{Nachteile:}
								\begin{itemize}
									\item Geringe Auflösung, es sind nur große Pixel realisierbar.
									\item Sensitiv gegenüber Hintergrundbeleuchtung.
									\item Interferenzen zwischen mehreren ToF Kameras.
									\item Mehrfachreflexionen durch großflächige Bestrahlung von Oberflächen.
								\end{itemize}
						\end{itemize}
					% end
				% end

				\subsubsection{Laserbasierte 3D-Sensoren}
					Es ist auch möglich, Tiefeninformationen ohne Kamerabilder zu generieren. Ein Beispiel hierfür sind Laserscanner. Diese können aus mehreren Lasern (Mehrfach-Lasersysteme) zusammengesetzt sein oder dreh-/schwenkbar sein (Mono-Lasersystem). Es ist ebenfalls möglich, Laserscanner und Kamerabilder zu kombinieren, um ein detaillierteres Weltbild zu erhalten.
				% end

				\subsubsection{Datenstrukturen und -Repräsentation}
					Eine klassische, unkomprimierte Punktwolke ("point cloud") benötigt sehr viel Speicherplatz, \dh es werden effektiver Datenrepräsentationen/-strukturen benötigt:
					\begin{itemize}
						\item Reduktion des Speicherbedarfs.
						\item Reduktion des Rechenaufwands bei der Verarbeitung.
						\item Effiziente Aggregation von 3D-Punkten.
						\item Effizienter Zugriff auf einzelne Punkte (\zB Nachbarschaftsinformationen).
					\end{itemize}

					\paragraph{KD-Baum}
						Ein \emph{KD-Baum} ist eine verallgemeinerte Version eines Binärbaums (KD steht für \(k\)-dimensional). Die geometrische Idee ist eine rekursive Aufteilung der Daten mit Hyperebenen.
						
						\begin{itemize}
							\item \textbf{Vorteile:}
								\begin{itemize}
									\item Anwendung der "Branch-and-Bound" Methode: Die Lage des Suchpunktes relativ zum aktuell betrachteten Knoten des Baums verrät, in welchem Unterteilbaum ein potentiell besserer (näherer) Knoten liegt.
									\item Es gibt Algorithmen, die \( \mathcal{O}(\log n) \) garantieren.
									\item Einfach erweiterbar auf \(k\)-nearest Search.
								\end{itemize}
							\item \textbf{Nachteile:}
								\begin{itemize}
									\item Das Einfügen und Entfernen von Punkten ist kompliziert (\ggf Rebalancierung des Baums notwendig).
									\item Keine Datenkompression und Aggregation.
								\end{itemize}
						\end{itemize}
					% end

					\paragraph{Octree}
						Ein \emph{Octree} unterteilt den Raum rekursiv-hierarchisch in \emph{Oktanten}. Er ist dabei ein gewurzelter Baum, indem jeder Knoten entweder acht oder keine Nachfolger hat.
						
						\begin{itemize}
							\item \textbf{Vorteile:}
								\begin{itemize}
									\item Leicht zu Implementieren.
									\item Geringer Speicherplatzbedarf bei dünnbesetzten Punktwolken.
									\item Mehrere Punkte können in einem Oktanten zusammengefasst werden.
									\item Einfaches Einfügen und Entfernen von Punkten.
									\item Effizienter Zugriff, da die Baumtiefe beschränkt ist.
									\item Raycasting-Algorithmen effizient umsetzbar.
								\end{itemize}
							\item \textbf{Nachteile:}
								\begin{itemize}
									\item Ineffiziente Nachbarschaftssuche.
									\item Kubische Datenrepräsentation vs. Längliche Umweltgeometrien.
									\item Auflösung beschränkt, da die Umwelt in ein festes Voxelgitter eingeteilt wird.
								\end{itemize}
						\end{itemize}
					% end

					\paragraph{Truncated Signed Distance Fields (TSDF)}
						\begin{itemize}
							\item \texttt{Truncated Signed Distance Fields} (TSDFs) werden als Voxelgitter gespeichert.
							\item Jede Zelle speichert dabei den Abstand zur nächsten Oberfläche.
							\item Zellen mit einem Wert nahe Null repräsentieren die \emph{Isolinie} der Oberfläche.
							\item Zellen fern von Oberflächen werden "gelöscht" (truncated).
							\item \textbf{Vorteile:}
								\begin{itemize}
									\item Oberflächen können annähernd beliebig genau erfasst werden.
									\item Mesh-Rekonstruktion ist "inklusive".
								\end{itemize}
							\item \textbf{Nachteile:}
								\begin{itemize}
									\item Voxelgitter benötigen enorm viel Speicherplatz (Lösung: Hashed TSDF).
									\item Updates sind rechenintensiv (häufig werden diese auf der GPU berechnet).
								\end{itemize}
						\end{itemize}
					% end
				% end

				\subsubsection{Point-Cloud Processing}
					\emph{Point Cloud Library} (PCL) eine eine umfangreiche Bibliothek zur Verarbeitung von 3D-Daten und ist die meist genutzte Bibliothek zur 3D-Datenverarbeitung (analog zu OpenCV in der 2D-Bildverarbeitung).
					
					\begin{itemize}
						\item Datenaufbesserung: Statistical Outlier Removal
							\begin{itemize}
								\item Viele Verfahren benötigen dichte Punktwolken.
								\item Daher ist eine Entfernung von Ausreißern notwendig.
								\item Analyse des mittleren Abstands zu den \(k\)-nächsten Nachbarn: Wird der Abstand zu groß, wird der Punkt entfernt.
							\end{itemize}
						\item Datenaufbesserung: Glättung (Smoothing)
							\begin{itemize}
								\item Oftmals sind 3D-Daten verrauscht, in Gebäuden gibt es jedoch oftmals glatte Oberflächen.
								\item Polynomial Reconstruction: Lokale Approximation mit Polynomen \(n\)-ter Ordnung approximiert.
								\item Resampling: Das Polynom wird verwendet, um den Punkt auf das ermittelte Polygon zu verschieben.
								\item Durch dieses Verfahren können auch Oberflächen rekonstruiert werden.
							\end{itemize}
						\item Informationsextraktion: Surface Normal Estimation
							\begin{itemize}
								\item Oberflächenkonstruktion ist häufig auf Oberflächennormale angewiesen.
								\item Eine Schätzung ist \bspw mittels Principal Component Analysis (PCA) möglich.
								\item Durch eine Singulärwertzerlegung werden die Eigenvektoren der Punkte gefunden.
								\item Der kleinste Eigenvektor entspricht dann der geschätzten Oberflächennormale.
							\end{itemize}
						\item Informationsextraktion: Plane Segmentation
					\end{itemize}
				% end

				\subsubsection{Point-Cloud Registration}
					Iterative Closest Point (ICP):
					\begin{itemize}
						\item Bestimmt den Versatz zweier Teilmengen von Punktwolken.
						\item Ansatz: Ist die korrekte Übereinstimmung der Punkte bekannt, so lässt sich die relative Transformation bestimmen.
						\item Dabei wird angenommen, dass die jeweils zueinander nächsten Punkte zueinander gehören (korrespondieren).
						\item Dann wird eine Transformation gesucht, die den quadratischen Fehler minimiert.
						\item Anschließend wir die Eingangspunktwolke basierend auf der Transformation verschoben.
						\item Dies wird so lange wiederholt, bis der Fehler konvergiert.
					\end{itemize}
				% end
			% end
		% end
	% end

	\chapter{Regelung} % S.158, S.159, S.160
		\section{Lineare Regelung}
			Bei einer "normalen" Steuerung (Abbildung~\ref{fig:feedforward_control}) findet keine Rückkopplung der tatsächlich durchgeführten Aktion statt, während bei einer Regelung (Abbildung~\ref{fig:feedback_control}) die Aktion gemessen wird und in das nächste Steuerungssignal eingerechnet wird.
			
			\begin{figure}
				\centering
				\begin{tikzpicture}[every node/.style = { align = center }]
					\node [draw, rectangle, minimum width = 5cm] (regelstrecke) {Roboter \\ (Regelstrecke)};
					\coordinate [left = 1 of regelstrecke, yshift = 2pt] (a);
					\coordinate [right = 1 of regelstrecke, yshift = 2pt] (b);
					\coordinate [left = 2 of regelstrecke] (A);
					\coordinate [right = 2 of regelstrecke] (B);
					\node [above = 1 of a] (eingangsgroesse) {Eingangsgröße: \\ Steuerungen der Antriebe \\ (Stellgröße)};
					\node [above = 1 of b] (ausgangsgroesse) {Ausgangsgröße: \\ Roboterbewegung \\ (in Raum und Zeit)};
					\node [above = 1 of regelstrecke] (stoergroesse) {Störgröße};
					
					\draw [->] (A) -- (regelstrecke);
					\draw [->] (regelstrecke) -- (B);
					\draw [->] (eingangsgroesse) -- (a);
					\draw [->] (ausgangsgroesse) -- (b);
					\draw [->] (stoergroesse) -- (regelstrecke);
				\end{tikzpicture}
				\caption{Blockschaltbild einer normalen Steuerung (Feedforward Control).}
				\label{fig:feedforward_control}
			\end{figure}
			\begin{figure}
				\centering
				\begin{tikzpicture}[every node/.style = { align = center }]
					\node [draw, rectangle, minimum width = 5cm] (regelstrecke) {Roboter \\ (Regelstrecke)};
					\coordinate [left = 1 of regelstrecke, yshift = 2pt] (a);
					\coordinate [right = 1 of regelstrecke, yshift = 2pt] (b);
					\coordinate [right = 1 of regelstrecke] (c);
					\node [draw, rectangle, left = 2 of regelstrecke] (A) {Regler \\ (Berechnungsverfahren)};
					\coordinate [right = 2 of regelstrecke] (B);
					\node [above = 1 of a] (eingangsgroesse) {Eingangsgröße: \\ Steuerungen der Antriebe \\ (Stellgröße)};
					\node [above = 1 of b] (ausgangsgroesse) {Ausgangsgröße: \\ Roboterbewegung \\ (in Raum und Zeit)};
					\node [above = 1 of regelstrecke] (stoergroesse) {Störgröße};
					\node [draw, rectangle, below = 1 of regelstrecke] (sensoren) {Sensoren};
					\node [draw, circle, left = 1 of A, label = above:Fehler] (fehler) {\(\Sigma\)};
					\coordinate [left = 1 of fehler] (d);
					
					\draw [->] (A) -- (regelstrecke);
					\draw [->] (regelstrecke) -- (B);
					\draw [->] (eingangsgroesse) -- (a);
					\draw [->] (ausgangsgroesse) -- (b);
					\draw [->] (stoergroesse) -- (regelstrecke);
					\draw [->] (c) |- (sensoren);
					\draw [->] (sensoren) -| (fehler) node[right, yshift = -0.5cm]{\(-\)};
					\draw [->] (fehler) -- (A);
					\draw [->] (d) -- (fehler) node[above, xshift = -0.5cm]{\(+\)};
				\end{tikzpicture}
				\caption{Blockschaltbild einer Regelung (Feedback Control).}
				\label{fig:feedback_control}
			\end{figure}

			\subsection{Begriffe}
				Eine Steuerung wird auch als Open-Loop oder Feedforward Control bezeichnet, eine Regelung als Closed-Loop oder Feedback Control.
				
				Im folgenden wird folgende Notation verwendet:
				\begin{itemize}
					\item Sollwert:    \tabto{2.5cm} \( x_d(t) \)
					\item Regelgröße:  \tabto{2.5cm} \( x(t) \)
					\item Messgröße:   \tabto{2.5cm} \( \tilde{x}(t) \)
					\item Regelfehler: \tabto{2.5cm} \( e(t) \)
					\item Stellgröße:  \tabto{2.5cm} \( u(t) \)
					\item Störung:     \tabto{2.5cm} \( s(t) \)
				\end{itemize}
				Abbildung~\ref{fig:control_notation} zeigt einen normalen Regelkreis mit den entsprechenden Größen.
				
				\begin{figure}
					\centering
					\begin{tikzpicture}
						\node [draw, rectangle] (regelstrecke) {Regelstrecke};
						\coordinate [right = 1 of regelstrecke] (c);
						\node [draw, rectangle, left = 1 of regelstrecke] (A) {Regler};
						\coordinate [right = 2 of regelstrecke] (B);
						\coordinate [above = 1 of regelstrecke] (stoergroesse);
						\node [draw, rectangle, below = 1 of regelstrecke] (sensoren) {Sensoren};
						\node [draw, circle, left = 1 of A] (fehler) {\(\Sigma\)};
						\coordinate [left = 1 of fehler] (d);
						
						\draw [->] (A) to node[above]{\(u(t)\)} (regelstrecke);
						\draw [->] (regelstrecke) to node[above]{\(x(t)\)} (B);
						\draw [->] (stoergroesse) to node[left]{\(s(t)\)} (regelstrecke);
						\draw [->] (c) |- node[below]{\(x(t)\)} (sensoren);
						\draw [->] (sensoren) -| node[below]{\(\tilde{x}(t)\)} (fehler) node[right, yshift = -0.5cm]{\(-\)};
						\draw [->] (fehler) to node[above]{\(e(t)\)} (A);
						\draw [->] (d) to node[above]{\(x_d(t)\)} (fehler);
					\end{tikzpicture}
					\caption{Die dynamischen Größen eines Regelkreises.}
					\label{fig:control_notation}
				\end{figure}
			
				Des weiteren seien folgende Begriffe definiert:
				\begin{itemize}
					\item \emph{Regelungstechnik:} Lehre der
						\begin{itemize}
							\item mathematischen Beschreibung und
							\item gezielten Beeinflussung
							\item dynamischer Prozesse
							\item in Technik, Biologie, Ökologie, Soziologie, \dots
						\end{itemize}
					\item \emph{Aufgabe der Regelung}
						\begin{itemize}
							\item Konstant halten oder gezieltes Ändern
							\item von einer oder mehreren Regel(ungs)größen
							\item unter Einwirkung von Störgrößen auf einen Prozess.
						\end{itemize}
					\item \emph{Führungsgröße} (Soll-Wert)
						\begin{itemize}
							\item Wenn konstant \(\to\) \emph{Festwertregelung}
							\item Wenn veränderlich (zeit- und/oder zustandsabhängig) \(\to\) \emph{Folgeregelung}
						\end{itemize}
					\item \emph{Regeln}
						\begin{itemize}
							\item Herstellen und Bewahren einer wünschenswerten Situation.
						\end{itemize}
					\item \emph{Steuerung}
						\begin{itemize}
							\item Nachstellen einer \emph{Stellgröße} nach gegebenen Kennlinien (Open-Loop Control, Feedforward Control).
						\end{itemize}
					\item \emph{Regelung}
						\begin{itemize}
							\item Nachstellen aufgrund laufender Messungen der Regelgrößen (Closed-Loop Control, Feedback Control).
						\end{itemize}
					\item \emph{Vermaschte Regelung}
						\begin{itemize}
							\item Mindestens zwei sich wechselseitig beeinflussende Regelkreise.
						\end{itemize}
					\item \emph{Kaskadenregelung}
						\begin{itemize}
							\item (Hierarchisch) überlagerte Regelkreise.
						\end{itemize}
					\item \emph{Stabilitätsproblem}
						\begin{itemize}
							\item Eine sprungartige Verstellung des Sollwerts führt zu einem verzögertem Einschwingvorgang der Regelgröße und einer verzögerten Ankunft des Korrektursignals.
							\item Eine kleine Regelabweichung soll ausreichen, um die Stellgröße zu steuern (über Kreisverstärkung in einem geschlossenem Regelkreis).
							\item Zeitverzug und Signalverstärkung führen zu Instabilität (\dh Schwingung um den Sollwert).
						\end{itemize}
				\end{itemize}
			% end

			\subsection{Lineare Systemdynamik und Feder-Masse-System} % S.161
				Im folgenden wird ein Feder-Masse-System mit der Masse \( m > 0 \), der Federsteifigkeit \( k > 0 \) und dem Reibungskoeffizienten \( b > 0 \) sowie einer Antriebs- oder Bremskraft \( f(t) \) betrachtet. Der Wert \( x \) beschreibt dabei die lineare Verschiebung der Masse \bzgl der Ruhelage um \( x_\text{stat}(t) = 0 \). Die Bewegungsgleichung lautet
				\begin{equation*}
					m\ddot{x}(t) + b\dot{x}(t) + kx(t) = f(t)
				\end{equation*}
				und ist eine lineare, inhomogene, gewöhnliche Differentialgleichung zweiter Ordnung mit konstanten Koeffizienten.

				\subsubsection{Untersuchung des Bewegungsverhaltens} % S.161, S.162, S.163
					Mit einer gegebenen Anfangsposition \( x(0) \) und einer gegebenen Anfangsgeschwindigkeit \( \dot{x}(0) \) sowie einem Antriebskraftverlauf \( f(t) \) kann der zeitliche Bewegungsverlauf der Masse aus der Bewegungsgleichung bestimmt werden.
					
					\paragraph{Erwartetes Bewegungsverhalten}
						Wird angenommen, dass \( f(t) = 0 \) gilt sowie \( x_\text{stat}(t) = 0 \) die Ruhelage darstellt, so lassen sich folgende Bewegungsmuster erkennen:
						\begin{itemize}
							\item Schwache Feder (\(k\) klein), große Reibungskraft (\(b\) groß): Die Masse wird aus einer Anfangsauslenkung \( x(0) \neq x_\text{stat} \) langsam in den stationären Zustand zurückkehren.
							\item Starke Feder (\(k\) groß), schwache Reibungskraft (\(b\) klein): Die Masse wird aus einer Anfangsauslenkung \( x(0) \neq x_\text{stat} \) mehrmals schnell hin und her schwingen (oszillieren), bis sie in den stationären Zustand zurückkehrt.
						\end{itemize}
					
						Unter der Annahme \( f(t) = 0 \) kann die Differentialgleichung mit dem Lösungsansatz \( x(t) = ce^{\lambda t} \) explizit gelöst werden, wodurch sich das charakteristische Polynom
						\begin{equation*}
							\lambda^2 + \frac{b}{m} \lambda + \frac{k}{m} = 0
						\end{equation*}
						mit den Nullstellen (den \emph{Polen})
						\begin{equation*}
							\lambda_{1, 2} = -\frac{b}{2m} \pm \frac{\sqrt{b^2} - 2mk}{2m}
						\end{equation*}
						ergibt. Diese Pole bestimmen das Lösungsverhalten und damit das Bewegungsverhalten der Masse.
						
						\subparagraph{Überkritisch Gedämpftes Verhalten}
							\( \lambda_{1, 2} \) sind einfache, reelle Nullstellen, wenn
							\begin{equation*}
								b^2 - 4mk > 0 \quad\iff\quad b^2 > 4mk
							\end{equation*}
							wodurch auch \( \lambda_{1, 2} < 0 \) gilt. Dieser Fall wird \emph{überkritisch gedämpft} genannt.
							
							Die Lösung ist in diesem Fall gegeben durch
							\begin{equation*}
								x(t) = c_1 e^{\lambda_1 t} + c_2 e^{\lambda_2 t}
							\end{equation*}
							wobei die Konstanten \( c_1, c_2 \) durch die Anfangsbedingungen festgelegt werden.
						% end
						
						\subparagraph{Kritisch Gedämpftes Verhalten}
							\( \lambda \) ist eine doppelte, reelle Nullstelle, wenn
							\begin{equation*}
								b^2 - 4mk = 0 \quad\iff\quad b^2 = 4mk
							\end{equation*}
							wodurch auch \( \lambda < 0 \) gilt. Dieser Fall wird \emph{kritisch gedämpft} genannt.
							
							Die Lösung ist in diesem Fall gegeben durch
							\begin{equation*}
								x(t) = c_1 e^{\lambda t} + c_2 t e^{\lambda t}
							\end{equation*}
							wobei die Konstanten \( c_1, c_2 \) durch die Anfangsbedingungen festgelegt werden.
						% end
						
						\subparagraph{Unterkritisch Gedämpftes Verhalten}
							\( \lambda_{1, 2} \) sind einfache, komplexe Nullstellen (mit \( \lambda_1 = \bar{\lambda}_2 \)), wenn
							\begin{equation*}
								b^2 - 4mk < 0 \quad\iff\quad b^2 < 4mk
							\end{equation*}
							wodurch mit \( \lambda_{1, 2} \eqqcolon \lambda_r \pm i \lambda_i \) auch \( \lambda_r < 0 \) gilt. Dieser Fall wird \emph{unterkritisch gedämpft} genannt.
							
							Die Lösung ist in diesem Fall gegeben durch
							\begin{equation*}
								c_1 e^{\lambda_r t} \cos(\lambda_i t) + c_2 e^{\lambda_r t} \sin(\lambda_i t)
							\end{equation*}
							wobei die Konstanten \( c_1, c_2 \) durch die Anfangsbedingungen festgelegt werden.
						% end
					% end

					\paragraph{Gewünschtes Bewegungsverhalten}
						Wünschenswert ist oftmals die kritische Dämpfung, da
						\begin{itemize}
							\item das System dabei aus einer Anfangsauslenkung \( x(0) \neq x_\text{stat} \) schnellstmöglich in die stationäre Lage zurückkehrt und
							\item keine Oszillationen oder Überschwingungen auftreten.
						\end{itemize}
					
						In der Regelungstechnik wird üblicherweise nicht im Zeitbereich gearbeitet, sondern die Laplace-Transformation zur Definition von Übertragungsfunktionen und der Untersuchung der Pole eingesetzt. Dies wird hier aber nicht weiter behandelt\dots
					% end
				% end
			% end

			\subsection{PD-Regelung linearer Systeme 2. Ordnung} % S.163, S.164
				Die Aufgabe der Regelung ist nun, ein gewünschtes Bewegungsverhalten durch geeignete Wahl der Steuerung zu erreichen.

				\subsubsection{Beispiel: Feder-Masse-System} % 6.103, 6.104, 6.105, 6.106
					Mit Hilfe von Sensoren zur Messung der Position \( x \) sowie der Geschwindigkeit \( \dot{x} \) und der Verwendung einer Antriebskraft \(f\) (Steuerung) und einem geeigneten Regelgesetz zur Bestimmung von \(f\) soll das Bewegungsverhalten so modifiziert werden, dass eine kritische Dämpfung eintritt. Der Ansatz für die erzeugte Kraft ist dabei die Funktion
					\begin{equation*}
						f(t) = -k_v \dot{x}(t) - k_p x(t)
					\end{equation*}
					mit den Regelparametern/Verstärkungsfaktoren \( k_v \) (Differentialanteil) und \( k_p \) (Proportionalanteil). Abbildung~\ref{fig:pd_control} zeigt das Blockschaltbild für eine solche Regelung.
					
					\begin{figure}
						\centering
						\begin{tikzpicture}
							\node [draw, rectangle, align = center, minimum height = 2cm] (regelstrecke) {System \\ \enquote{Regelstrecke}};
							\coordinate [above = 0.5 of regelstrecke.east] (x);
							\coordinate [below = 0.5 of regelstrecke.east] (xDot);
							\coordinate [right = 1.5 of x] (xPathA);
							\coordinate [right = 1 of xDot] (xDotPathA);
							\coordinate [below = 2 of xDot] (xDotPath);
							\coordinate [below = 0.5 of xDotPath] (xPath);
							\node [draw, circle, left = 2 of regelstrecke] (pd) {\(\Sigma\)};
							\node [draw, rectangle, below right = of pd, xshift = -1cm] (kv) {\(k_v\)};
							\node [draw, rectangle, below left = of pd, xshift = 1cm] (kp) {\(k_p\)};
							\node [above right = 0 of x] {\(x\)};
							\node [above right = 0 of xDot] {\(\dot{x}\)};
							
							\draw [->] (x) -- (xPathA) |- (xPath) -| (kp);
							\draw [->] (xDot) -- (xDotPathA) |- (xDotPath) -| (kv);
							\draw [->] (kp) -- (pd) node[left, xshift = -0.2cm, yshift = -0.5cm]{\(-\)};
							\draw [->] (kv) -- (pd) node[right, xshift = 0.2cm, yshift = -0.5cm]{\(-\)};
							\draw [->] (pd) -- node[above]{\(f\)} (regelstrecke);
						\end{tikzpicture}
						\caption{Blockschaltbild einer PD-Regelung mit den Soll-Werten \( x_d, \dot{x}_d \).}
						\label{fig:pd_control}
					\end{figure}
				
					Wird das Regelgesetz auf die Bewegungsgleichung angewandt, so ergibt sich:
					\begin{align*}
						     &  & m\ddot{x}(t) + b\dot{x}(t) + kx(t)                                                                 & = f(t)                       &  \\
						\iff &  & m\ddot{x}(t) + b\dot{x}(t) + kx(t)                                                                 & = -k_v \dot{x}(t) - k_p x(t) &  \\
						\iff &  & m\ddot{x}(t) + \underbrace{(b + k_v)}_{\hat{b}} \dot{x}(t) + \underbrace{(k + k_p)}_{\hat{k}} x(t) & = 0                          &
					\end{align*}
					Die Pole des geregelten Systems entsprechen den Nullstellen des charakteristischen Polynoms:
					\begin{equation*}
						\lambda_{1, 2} = -\frac{\hat{b}}{2m} \pm \frac{\sqrt{\hat{b}^2 - 4m\hat{k}}}{2m}
					\end{equation*}
					Durch geeignete Wahl der Regelparameter \( k_v, k_p \) kann also das gewünschte Bewegungsverhalten der kritischen Dämpfung erreicht werden.
					
					Neben der Bedingung \( \hat{b}^2 = 2m\hat{k} \) muss (da diese noch nicht ausreichend ist für eine kritische Dämpfung, da \( k_v \) und \( k_p \) positiv oder negativ gewählt werden können) unter anderem \( \hat{b} > 0 \) sichergestellt werden, da Regelfehler sonst die Instabilität verstärken statt dämpfen würde.
					
					\begin{itemize}
						\item Auf diese Weise kann das System auf einen konstanten Sollwert \( x_d \) geregelt werden (Festpunktregelung).
						\item Analog dazu kann die Regelung auch auf eine gegebene Sollwerttrajektorie \( x_d(t) \) erweitert werden.
						\item Ebenfalls kann das System auf mehrdimensionale und nichtlineare Systeme erweitert werden.
					\end{itemize}
				
					\paragraph{Gewünschte Polplatzierung}
						Damit das geregelte System stabil ist, müssen die Pole des Systems in der linken Hälfte der komplexen Ebene liegen (\dh der Realteil muss negativ sein).
					% end
				% end
			% end

			\subsection{Partitionierung des Regelgesetzes durch Feedback-Linearisierung} % 6.107, 6.108, S.165, S.166
				\todo{Content}
			% end

			\subsection{Sollwerttrajektorien-Folgeregelung} % 6.109, 6.110, S.166, S.167
				\todo{Content}
			% end

			\subsection{PID-Regelung linearer Systeme} % 6.115, S.167, S.168
				Mit den Sollwerten \( x_d, \dot{x}_d \) für Position und Geschwindigkeit lautet das PID-Regelgesetz
				\begin{equation*}
					f = k_v \underbrace{(\dot{x}_d - \dot{x})}_{\dot{e}} + k_p \underbrace{(x_d - x)}_{e} + k_i \int \! \underbrace{(k_d - x)}_{e} \dif{t}
				\end{equation*}
				wobei \( e \coloneqq x_d - x \) und \( \dot{e} \coloneqq \dot{x}_d - \dot{x} \) den Positions- und Geschwindigkeitsfehler darstellen. Das Blockschaltbild der PID-Regelung ist in Abbildung~\ref{fig:pid_control} gegeben. Die Wirkung der drei Terme (Differential, Proportional und Integral) haben folgende intuitive Effekte:
				\begin{itemize}
					\item Der Differentialteil "schaut in die Zukunft" und führt zu einer vorausschauenden Regelung,
					\item der Proportionalteil "schaut auf die Gegenwart" und führt zu einer akuten Regelung und
					\item der Integralteil "schaut in die Vergangenheit" und korrigiert (regelt) Fehler raus, die in der Vergangenheit gemacht wurden.
				\end{itemize}
			
				\begin{figure}
					\centering
					\begin{tikzpicture}
						\node [draw, rectangle, align = center, minimum height = 2cm] (regelstrecke) {System \\ \enquote{Regelstrecke}};
						\coordinate [above = 0.5 of regelstrecke.east] (x);
						\coordinate [below = 0.5 of regelstrecke.east] (xDot);
						\coordinate [right = 1.5 of x] (xPathA);
						\coordinate [right = 1 of xDot] (xDotPathA);
						\coordinate [below = 2 of xDot] (xDotPath);
						\coordinate [below = 0.5 of xDotPath] (xPath);
						\node [above right = 0 of x] {\(x\)};
						\node [above right = 0 of xDot] {\(\dot{x}\)};
						
						\node [draw, circle, left = 2 of regelstrecke] (add1) {};
						\coordinate [below = 0.5 of add1] (a);
						\node [draw, circle, left = 1 of a] (add2) {};
						\node [draw, rectangle, below left = of add2, yshift = 0.8cm] (kv) {\(k_v\)};
						\node [draw, rectangle, above left = of add2, yshift = -0.8cm] (kp) {\(k_p\)};
						
						\coordinate [above = 1 of add1] (b);
						\node [draw, rectangle, left = 1.5 of b] (ki) {\(k_i\)};
						\node [draw, rectangle, left = 0.1 of ki] (integral) {\(\int\)};
						
						\coordinate [left = 0.5 of kv] (c);
						\path let \p1 = (c), \p2 = (xDotPath) in node [draw, circle] (e) at (\x1, \y2) {};
						\coordinate [left = 0.5 of e] (f);
						\path let \p1 = (f), \p2 = (xPath) in node [draw, circle] (g) at (\x1, \y2) {};
						\node [left = 0.5 of g] (xd) {\(x_d\)};
						\path let \p1 = (xd), \p2 = (e) in node (xDotd) at (\x1, \y2) {\(\dot{x}_d\)};
						
						\draw [->] (x) -- (xPathA) |- (xPath) -- (g) node[below, xshift = 0.5cm, yshift = 0.05cm]{\(-\)};
						\draw [->] (xDot) -- (xDotPathA) |- (xDotPath) -- (e) node[above, xshift = 0.5cm, yshift = -0.05cm]{\(-\)};
						\draw [->] (add1) -- node[above]{\(f\)} (regelstrecke);
						\draw [->] (kv) -| (add2);
						\draw [->] (kp) -| (add2);
						\draw [->] (add2) -| (add1);
						\draw [->] (integral) -- (ki) -| (add1);
						\draw [->] (g) |- coordinate[label = left:\(e\)](h) (kp);
						\draw [->] (e) |- node[left]{\(\dot{e}\)} (kv);
						\draw [->] (h) |- (integral);
						\draw [->] (xd) -- (g);
						\draw [->] (xDotd) -- (e);
					\end{tikzpicture}
					\caption{Blockschaltbild eines PID-Reglers mit den Sollwerten \( x_d, \dot{x}_d \).}
					\label{fig:pid_control}
				\end{figure}
			
				\subsubsection{Windup-Effekt}
					Üblicherweise ist die maximale Stellleistung endlich, \dh jede Stellgröße \(f\) ist auf einen maximalen Wertebereich \( \big[ -f_\text{max},\, f_\text{max} \big] \) begrenzt.
					
					Problem: Der I-Anteil des Reglers integriert auch nach Erreichen der Sättigung der Stellgröße die Regelabweichung weiter auf, obwohl der Reglerausgang keinen Einfluss mehr auf die Regelstrecke hat. Beim Erreichen der Zielvorgabe kann \( \lvert f \rvert \) dadurch deutlich größer als \( f_\text{max} \) sein, wodurch dieser Überschuss zunächst wieder abgebaut werden muss. Dieser Effekt wird als \emph{Windup-Effekt} bezeichnet und verschlechtert das Regelverhalten (Überschwingen).
					
					Zur "Schadensbegrenzung" müssen Anti-Windup-Maßnahmen eingesetzt werden, \bspw die Begrenzung des I-Anteils bei Auftreten der Sättigung. Dazu wird die Differenz \( \tilde{f} - f \) zwischen Stellgröße \(f\) und begrenzter Stellgröße \( \tilde{f} \) über ein P-Glied mit Verstärkung \( k_\text{aw} \) zurück gekoppelt. Diese Rückkopplung hat keinen Einfluss, wenn \( f \in \big[ -f_\text{max},\, f_\text{max} \big] \) gilt. Abbildung~\ref{fig:pid_control_anti_windup} zeigt das Blockschaltbild einer solchen Anti-Windup-Strategie.
					
					\begin{figure}
						\centering
						\begin{tikzpicture}
						\node [draw, rectangle, align = center, minimum height = 2cm] (regelstrecke) {System \\ \enquote{Regelstrecke}};
						\node [draw, rectangle, align = center, left = 1 of regelstrecke] (stellgliedbegrenzung) {Stellgliedbegrenzung};
						\coordinate [above = 0.5 of regelstrecke.east] (x);
						\coordinate [below = 0.5 of regelstrecke.east] (xDot);
						\coordinate [right = 1.5 of x] (xPathA);
						\coordinate [right = 1 of xDot] (xDotPathA);
						\coordinate [below = 2 of xDot] (xDotPath);
						\coordinate [below = 0.5 of xDotPath] (xPath);
						\node [above right = 0 of x] {\(x\)};
						\node [above right = 0 of xDot] {\(\dot{x}\)};
						
						\node [draw, circle, left = 1 of stellgliedbegrenzung] (add1) {};
						\coordinate [below = 0.5 of add1] (a);
						\node [draw, circle, left = 1 of a] (add2) {};
						\node [draw, rectangle, below left = of add2, yshift = 0.8cm] (kv) {\(k_v\)};
						\node [draw, rectangle, above left = of add2, yshift = -0.8cm] (kp) {\(k_p\)};
						
						\coordinate [above = 1 of add1] (b);
						\node [draw, rectangle, left = 1.5 of b] (ki) {\(k_i\)};
						\node [draw, rectangle, left = 0.1 of ki] (integral) {\(\int\)};
						
						\coordinate [left = 0.5 of kv] (c);
						\path let \p1 = (c), \p2 = (xDotPath) in node [draw, circle] (e) at (\x1, \y2) {};
						\coordinate [left = 0.5 of e] (f);
						\path let \p1 = (f), \p2 = (xPath) in node [draw, circle] (g) at (\x1, \y2) {};
						\node [left = 0.5 of g] (xd) {\(x_d\)};
						\path let \p1 = (xd), \p2 = (e) in node (xDotd) at (\x1, \y2) {\(\dot{x}_d\)};
						
						\path (add1) -- coordinate(i) (stellgliedbegrenzung);
						\path (stellgliedbegrenzung) -- coordinate(j) (regelstrecke);
						\node [draw, circle, above = 2 of i] (k) {};
						\node [draw, rectangle, left = 2 of k] (l) {\(k_\text{aw}\)};
						\path let \p1 = (integral), \p2 = (g) in node [draw, circle] (m) at (\x2, \y1) {};
						
						\draw [->] (x) -- (xPathA) |- (xPath) -- (g) node[below, xshift = 0.5cm, yshift = 0.05cm]{\(-\)};
						\draw [->] (xDot) -- (xDotPathA) |- (xDotPath) -- (e) node[above, xshift = 0.5cm, yshift = -0.05cm]{\(-\)};
						\draw [->] (add1) -- node[below]{\(f\)} (stellgliedbegrenzung);
						\draw [->] (stellgliedbegrenzung) -- node[below]{\(\tilde{f}\)} (regelstrecke);
						\draw [->] (kv) -| (add2);
						\draw [->] (kp) -| (add2);
						\draw [->] (add2) -| (add1);
						\draw [->] (integral) -- (ki) -| (add1);
						\draw [->] (g) |- coordinate[label = left:\(e\)](h) (kp);
						\draw [->] (e) |- node[left]{\(\dot{e}\)} (kv);
						\draw [->] (h) -- (m);
						\draw [->] (m) -- (integral);
						\draw [->] (xd) -- (g);
						\draw [->] (xDotd) -- (e);
						\draw [->] (i) -- (k) node[right, yshift = -0.4cm]{\(-\)};
						\draw [->] (j) |- (k);
						\draw [->] (k) -- (l);
						\draw [->] (l) -| (m);
						\end{tikzpicture}
						\caption{Blockschaltbild eines PID-Reglers mit Anti-Windup-Teil.}
						\label{fig:pid_control_anti_windup}
					\end{figure}
				% end
			% end

			\subsection{Kaskadenregelung}
				Bei einer \emph{Kaskadenregelung} werden mehrere Regler hintereinander geschaltet (siehe Abbildung~\ref{fig:cascade_control}), wobei die Führungsgröße des "inneren" Reglers von einem "äußeren" Regler eingestellt wird. Dadurch können \bspw verschiedene Taktraten umgesetzt werden (\zB eine geringere Taktrate zur Berechnung der Gelenkstellungen und eine hohe Taktrate zur individuellen PID-Gelenkreglung).
				
				\begin{figure}
					\centering
					\begin{tikzpicture}[->, every node/.style = { align = center }]
						\coordinate (a);
						\node [draw, circle, right = 1 of a] (b) {};
						\node [draw, rectangle, right = 1 of b] (c) {Regler A \\ \enquote{Außen}};
						\node [draw, circle, right = 1 of c] (d) {};
						\node [draw, rectangle, right = 1 of d] (e) {Regler I \\ \enquote{Innen}};
						\node [draw, rectangle, right = 1 of e] (f) {System I \\ \enquote{Innen}};
						\coordinate [right = 1 of f] (g);
						\node [draw, rectangle, right = 1 of g] (h) {System A \\ \enquote{Außen}};
						\coordinate [right = 1 of h] (i);
						
						\coordinate [below = 1 of g] (j);
						\coordinate [below = 1.5 of i] (k);
						
						\draw (a) -- node[above]{Soll A} (b);
						\draw (b) -- (c);
						\draw (c) -- node[above]{Soll I} (d);
						\draw (d) -- (e);
						\draw (e) -- (f);
						\draw (f) -- node[above]{Ist I} (g) -- (h);
						\draw (g) -- (j) -| (d) node[right, yshift = -0.4cm]{\(-\)};
						\draw (h) -- node[above]{Ist A} (i) -- (k) -| (b) node[right, yshift = -0.4cm]{\(-\)};
					\end{tikzpicture}
					\caption{Blockschaltbild einer allgemeinen Kaskadenregelung.}
					\label{fig:cascade_control}
				\end{figure}
			% end

			\subsection{Stabilität als Sprungantwortverhalten und PID-Parameter}
				Wird der Sollwert \( x_d(t) \) als Sprung/Stufe gegeben, so hängt die Reaktion des Reglers (\bzw der rückgekoppelten Werte) von dem Dämpfungsgrad des Systems ab. Möglich sind dabei folgende Verhaltensweisen:
				\begin{enumerate}
					\item Hunting: Oszillation um den Sollwert (ohne diesen zu erreichen).
					\item Ringing: Überschwingen, aber konvergieren gegen den Sollwert.
					\item Overshoot (underdamped): Unterkritische Dämpfung, Überschießen. Die Kontrollparameter sind zu hoch, es besteht Gefahr für Beschädigungen bei Greif- und Transportaufgaben.
					\item Overdamped: Überkritische Dämpfung, der Sollwert wird nur langsam erreicht (ohne Überschießen).
					\item Critically Damped: Kritische Dämpfung, der Sollwert wird bei minimaler Verzögerung ohne Überschießen erreicht. Dies ist das ideale Verhalten.
				\end{enumerate}
			
				Schwierigkeiten bei der Regelung:
				\begin{itemize}
					\item Einstellung der Regelparameter und Regelstruktur.
					\item Nichtlineare Roboterdynamik
					\item Veränderung der Parameter im Laufe der Zeit (\zB durch Veränderung der Nutzlast oder durch Verschleiß).
				\end{itemize}

				\subsubsection{Einstellung der PID-Parameter}
					Für die Einstellung der Parameter, \bzw deren Analyse und Auswertung, sind folgende Metriken relevant:
					\begin{itemize}
						\item \emph{Ausregelzeit} \\ Die Zeitspanne, bis der Sollwerttoleranzbereich dauerhaft erreicht wird.
						\item \emph{Anregelzeit} \\ Die Zeitspanne von Sprungeingabe bis zum erstmaligen Erreichen des Sollwerttoleranzbereichs.
						\item \emph{Überschwingweite} \\ Prozentualer Wert des Überschwingens des Endwertes bei der ersten Oszillation.
					\end{itemize}
				
					Zur Einstellung der PID-Parameter kommen zwei grundlegende Verfahren in Frage:
					\begin{enumerate}
						\item Bei einem bekanntem mathematischen Modell der Prozessdynamik (Transferfunktion) können analytische Methoden angewendet werden, um die Parameter zu bestimmen (und damit die transienten und stationären Spezifikationen zu erfüllen).
						\item Ist die Systemdynamik nicht ausreichend bekannt, so müssen die Parameter experimentell eingestellt werden, \zB nach dem verfahren nach Ziegler-Nichols:
							\begin{itemize}
								\item Der Regelkreis wird mit einem einfachen P-Regler durch Vergrößerung von \(k_p\) an die Stabilitätsgrenze (der Wert, bis zu dem ungedämpfte Schwingungen auftreten) \( k_p = K \) gebracht.
								\item Sei \(P\) die Schwingungsdauer, dann können die restlichen Parameter wie folgt bestimmt werden (Heuristik!):
									\begin{itemize}
										\item Für P-Regler:   \tabto{3cm} \( k_p = 0.5K \)
										\item Für PI-Regler:  \tabto{3cm} \( k_p = 0.45K \) \tabto{5.5cm} \( k_i = 1.2 / P \)
										\item Für PID-Regler: \tabto{3cm} \( k_p = 0.6K \)  \tabto{5.5cm} \( k_i = 2.0 / P \) \tabto{8cm} \( k_v = P / 8.0 \)
									\end{itemize}
							\end{itemize}
					\end{enumerate}
				% end
			% end

			\subsection{Digitale Implementierung eines PID-Reglers und Diskretisierung}
				Wird ein PID-Regler digital implementiert, so müssen die I- und D-Terme diskret approximiert werden. Für ein Zeitintervall der Länge \num{1} heißt das:
				\begin{itemize}
					\item P-Term: \tabto{2cm} \( e_i = q_d - q \) zur Zeit \(i\)
					\item I-Term: \tabto{2cm} \( \sum_{i = 0}^{i = \text{jetzt}} e_i \)
					\item D-Term: \tabto{2cm} \( e_i - e_{i - 1} \)
				\end{itemize}
				Diese Diskretisierung kann das Systemverhalten stark beeinflussen! Ist die Abtastrate \( F_\text{abtast} \) nicht hoch genug, so können Aliasing-Effekte auftreten (\dh bestimmte Muster werden nicht erkannt, die Frequenz erscheint nach der Abtastung geringer als sie tatsächlich ist). Nach dem Nyquist-Shannon-Abtasttheorem muss die Abtastrate zur Vermeidung von Alias-Effekten größer als das doppelte der Analogen Frequenz \( F_\text{analog} \) sein:
				\begin{equation*}
					F_\text{abtast} > 2 F_\text{analog}
				\end{equation*}
				In der Praxis ist eine typische Wahl für die Abtastfrequenz \( 1/5 \) bis \( 1/10 \) der Anregelzeit.
			% end
		% end

		\section{Nichtlineare Regelung}
			Im Gegensatz zu dem Feder-Masse-System ist die Roboterdynamik \iA nichtlinear, mehrdimensional und in allen Gelenken verkoppelt. Die allgemeine Form einer Systemdynamik erster Ordnung\footnote{alle Dynamiken lassen sich auf ein solchen System zurückführen} lautet:
			\begin{equation*}
				\dot{\vec{x}}(t) =
					\begin{bmatrix}
						\dot{x}_1(t) \\
						\vdots \\
						\dot{x}_m(t)
					\end{bmatrix}
				=
					\begin{bmatrix}
						f_1\big(\vec{x}(t), \vec{u}(t)\big) \\
						\vdots \\
						f_m\big(\vec{x}(t), \vec{u}(t)\big)
					\end{bmatrix}
				= \vec{f}\big(\vec{x}(t), \vec{u}(t)\big)
			\end{equation*}
			mit dem Zustandsvektor \( \vec{x}(t) = \begin{bmatrix} x_1(t) & \cdots & x_m(t) \end{bmatrix}^T \) und den Steuerungsgrößen \( \vec{u}(t) = \begin{bmatrix} u_1(t) & \cdots & u_l(t) \end{bmatrix}^T \).
			
			\subsection{Systemlinearisierung}
				Eine lineare Systemdynamik hat die Form \( \vec{f}\big(\vec{x}(t), \vec{u}(t)\big) = \mat{A} \vec{x}(t) + \mat{B} \vec{u}(t) \) mit zwei konstanten Matrizen \( A \in \R^{m \times m} \) und \( B \in \R^{m \times l} \). Ein nichtlineares System \( \vec{f}\big(\vec{x}(t), \vec{u}(t)\big) \) kann lokal um einen Arbeitspunkt (\bspw die Ruhelage) \( (\vec{x}_0, \vec{u}_0) \) durch die Taylorentwicklung
				\begin{equation*}
					\dot{\vec{x}}_0 + \Delta\dot{\vec{x}}(t) = \vec{f}(\vec{x}_0, \vec{u}_0) + \mat{J}_{\vec{x}}(\vec{x}_0, \vec{u}_0) \cdot \Delta\vec{x}(t) + \mat{J}_{\vec{u}}(\vec{x}_0, \vec{u}_0) \cdot \Delta\vec{u}(t) + \vec{\xi}(t)
				\end{equation*}
				linearisiert werden, indem das Restglied \(\vec{\xi}(t)\) entfernt wird. Dadurch ergibt sich folgendes linearisiertes System:
				\begin{equation*}
					\Delta\dot{\vec{x}}(t) = \mat{J}_{\vec{x}}(\vec{x}_0, \vec{u}_0) \cdot \Delta\vec{x}(t) + \mat{J}_{\vec{u}}(\vec{x}_0, \vec{u}_0) \cdot \Delta\vec{u}(t)
				\end{equation*}
				mit \( \Delta\vec{x}(t) = \vec{x}(t) - \vec{x}_0 \) und \( \Delta\vec{u}(t) = \vec{u}(t) - \vec{u}_0 \) sowie den Jacobi-Matrizen \( \mat{J}_{\vec{x}}(\vec{x}_0, \vec{u}_0) \) und \( \mat{J}_{\vec{u}}(\vec{x}_0, \vec{u}_0) \) ausgewertet am Arbeitspunkt \( (\vec{x}_0, \vec{u}_0) \).
				
				Achtung: Dieses linearisierte Systems gilt nur approximativ um den Arbeitspunkt und kann nicht global verwendet werden!
			% end

			\subsection{Modellbasierte Manipulatorregelung}
				Zur Systemlinearisierung gibt es drei Grundlegende Ansätze:
				\begin{enumerate}
					\item Lokale Linearisierung um einen Arbeitspunkt \\ Problem: Ein Roboter bewegt sich ständig über unterschiedliche Bereiche und keine Linearisierung kann überall gültig sein.
					\item Verwendung vieler Linearisierungen und Verschiebung des Arbeitspunktes mit der Bewegung des Roboters \\ Problem: Wenig praktikabel, da hoher Rechenaufwand.
					\item Verwendung der inversen Roboterdynamik
				\end{enumerate}
				\begin{equation*}
					\vec{\tau} = \mat{M}(\vec{q}) \ddot{\vec{q}} + \vec{C}(\vec{q}, \dot{\vec{q}}) + \vec{G}(\vec{q}) + \vec{F}(\vec{q}, \dot{\vec{q}})
				\end{equation*}
				\begin{enumerate}
					\item[] und Partitionierung der Reglerstruktur:
				\end{enumerate}
				\vspace{-0.5cm}
				\begin{align*}
					\vec{\tau}       & = \mat{M}(\vec{q})\hat{\vec{\tau}} + \vec{C}(\vec{q}, \dot{\vec{q}}) + \vec{G}(\vec{q}) + \vec{F}(\vec{q}, \dot{\vec{q}}) \\
					\hat{\vec{\tau}} & = \ddot{\vec{q}}_d + \mat{K}_v \dot{\vec{e}} + \mat{K}_p \vec{e}                                                          \\
					\vec{e}          & = \vec{q}_d - \vec{q}
				\end{align*}
				Dadurch werden die \(n\) Gleichungen entkoppelt und das Regelgesetz "linearisiert" (entkoppelt).
				
				\begin{itemize}
					\item Diese für allgemeine Regelstrecken anwendbare, modellbasierte Regelungsmethode ("feedback linearization") wird auch als "inverse dynamics control" bezeichnet und ist eng verwandt mit "computed torque control".
					\item Die Realisierung setzt voraus, dass die Gelenkregelung zentral (\dh nicht wie bei einer Kaskadenregelung) geschieht. Bei den meisten Industrierobotern ist dies nicht möglich, \bzw technisch nicht vorgesehen.
					\item Der der Praxis muss die Roboterdynamik in Echtzeit berechnet werden, weshalb die Gleichungen entweder "von Hand" optimiert werden müssen oder sehr leistungsfähige Mikroprozessoren notwendig sind.
					\item Die Parameter der Dynamik müssen ausreichend bekannt sein (gute Reibungsmodelle sind \iA schwierig, Trägheit und Massen, Unsicherheiten, \dots).
					\item Vorteil: Es sind hohe Genauigkeiten und Geschwindigkeiten in der Bewegung erreichbar.
				\end{itemize}
			% end

			\subsection{Adaptive Manipulatorregelung}
				Bei der adaptiven Regelung wieder die modellbasierte Regelung mit Dynamikmodell kombiniert mit einem Adaptionsverfahren, um die Modellparameter durch Vergleich von berechneter und gemessener Zustände anzupassen (\bspw mittels Gaussian Process Regression).
			% end

			\subsection{Bahnreglung in Weltkoordinaten}
				Die Bahnregelung kann direkt (naiv) durch Nutzung der (inversen) Kinematik und der (inversen) Jacobi-Formulieren in Weltkoordinaten genutzt werden. Besser ist allerdings eine direkte Messung der Position in Weltkoordinaten als die (aufwendige und Fehlerbehaftete) Umrechnung.
			% end
		% end

		\section{Kraft-/Momenten-Regelung} % 6.158, 6.159, 6.160, 6.161, 6.162
			Manipulationsaufgaben erfordern den gezielten Umgang mit dem physikalischen Kontakt des Roboters mit der Umwelt. Bei einer reinen Positionsregelung können kleine Variationen der Positionen extrem große Kontaktkräfte hervorrufen. Dadurch können Schäden hervorgerufen werden, \bspw beim hantieren mit Glas. Somit ist ebenfalls eine Messung sowie Regelung der Kontaktkräfte und -momente nötig.
			
			\todo{Content}
		% end

		\section{Bahn-/Kraft-Regelung}
			\subsection{Hybride Regelung} % 6.163, 6.164, 6.165
				\todo{Content}
			% end

			\subsection{Parallele Regelung} % 6.166, 6.167
				\todo{Content}
			% end
		% end

		\section{Nachgiebigkeitsregelung (Compliant Control)} % 6.168, 6.169, 6.170, 6.171
			\todo{Content}

			\subsection{Verallgemeinerte Betrachtung nach Hogan} % 6.172, 6.173
				\todo{Content}
			% end

			\subsection{Impedanzregelung} % 6.174, 6.175
				\todo{Content}

				\subsubsection{Greifen} % 6.179, 6.180, 6.181, 6.182, 6.183, 6.184
					\todo{Content}
				% end
			% end

			\subsection{Admittanzregelung} % 6.185, 6.186, 6.187, 6.188, 6.191, 6.192
				\todo{Content}

				\subsubsection{Implementierung} % 6.189, 6.190
					\todo{Content}
				% end
			% end

			\subsection{Aktiv-passive Konzepte für Impedanz/Admittanz} % 6.193, 6.194
				\todo{Content}
			% end
		% end

		\section{Bildgeführte Regelung} % 6.195, 6.196, 6.197, 
			\todo{Content}

			\subsection{Positionsbasiert} % 6.198
				\todo{Content}
			% end

			\subsection{Bildbasiert} % 6.199, 6.200
				\todo{Content}
			% end
		% end

		\section{Multimodale Regelung physikalischer Interaktionen} % 6.202, 6.203, 6.204, 6.205, 6.206
			\todo{Content}
		% end

		\section{Regelung und Steuerung bei Mensch und Tier} % 6.207, 6.208, 6.228
			\todo{Content}

			\subsection{Propriozeption} % 6.209
				\todo{Content}
			% end

			\subsection{Sensoren} % 6.210
				\todo{Content}
			% end

			\subsection{Zentrales Nervensystem} % 6.211, 6.212, 6.213, 6.214, 6.215, 6.216, 6.217
				\todo{Content}
			% end

			\subsection{Neurale Integration} % 6.218, 6.219
				\todo{Content}
			% end

			\subsection{Informationsverarbeitung} % 6.220
				\todo{Content}

				\subsubsection{Reflexe} % 6.221, 6.222, 6.223
					\todo{Content}
				% end
			% end

			\subsection{Sonstiges} % 6.224, 6.225, 6.226, 6.227
				\todo{Content}
			% end
		% end

		\section{Elementare Roboterbewegungen} % 6.229
			\todo{Content}

			\subsection{Elementare Bewegungsarten für Industrieroboter} % 6.230, 6.231
				\todo{Content}

				\subsubsection{Lineare Interpolation in Gelenkkoordinaten} % 6.232, 6.233, 6.234
					\todo{Content}
				% end

				\subsubsection{Lineare Interpolation in Weltkoordinaten} % 6.235
					\todo{Content}
				% end

				\subsubsection{Kreisbogen-Interpolation} % 6.236
					\todo{Content}
				% end

				\subsubsection{Spline-Interpolation} % 6.236
					\todo{Content}
				% end
			% end

			\subsection{Schwierigkeiten bei kartesischer Bahnvorgabe} % 6.237, 6.238
				\todo{Content}
			% end

			\subsection{Programmierung einer Bahn als Folge elementarer Bewegungen} % 6.239, 6.240, 6.241, 6.242, 6.243
				\todo{Content}
			% end

			\subsection{Elementare Bewegungsarten für fahrende Roboter} % 6.244, 6.245, 6.246
				\todo{Content}
			% end

			\subsection{Elementare Bewegungsarten für laufende Roboter} % 6.247, 6.248, 6.249, 6.250, 6.251, 6.252, 6.253, 6.254, 6.255, 6.256, 6.257, 6.258
				\todo{Content}
			% end
		% end
	% end

	\chapter{Bahnplanung}
		\label{c:bahnplanung}
	
		Abbildung~\ref{fig:job_processing_and_planning} zeigt den typischen hierarchischen Aufbau der Auftragsbearbeitung und Planung, wobei sich dieses Kapitel auf die topologische, geometrische, kinematische und kinetische Planung bezieht.
		
		Die \emph{Bahnplanung} ist eine wichtige Mindestanforderung an "autonome", mobile Roboter und beinhaltet die Planung und Umsetzung eigener Bewegungen. Benötigt werden dazu
		\begin{itemize}
			\item Die Start- und Ziel-RAN,
			\item eine geeignete, interne Repräsentation der "Welt", \dh der Umwelt und des Roboters sowie
			\item Algorithmen, um sinnvolle Schlussfolgerungen/Planungen zu ermöglichen.
		\end{itemize}
		Die interne Repräsentation des Raumes (als Teil der Umwelt) beinhaltet dabei die Darstellung des frei befahrbaren Raumes und das Erkennen von Bereichen/Position und Objekten in der Umgebung. Diese Repräsentationen können in zwei Klassen eingeteilt werden:
		\begin{itemize}
			\item Topologisch (abstrakte Wege)
			\item Metrisch (geometrische Bahnen und Trajektorien)
		\end{itemize}
		Für die folgenden Betrachtungen seien zunächst einige Begriffe definiert:
		\begin{itemize}
			\item \emph{Weg} \\ Benannte Verbindung zwischen zwei Punkten, wobei die konkrete Bewegung entlang des Weges nicht berücksichtigt wird.
			\item \emph{Bahn/Pfad} \\ Kontinuierliche Punktfolge mit Position und Orientierung, \bspw bewegen sich Planeten auf einer Bahn.
			\item \emph{Trajektorie} \\ Bahn mit zeitlichen Verlaufsinformationen, \dh Positions-, Geschwindigkeits und \ggf Beschleunigungswerte. Bahnen/Trajektorien gibt es dabei im \(n\)-dimensionalen Gelenkraum (Konfigurationsraum) sowie im \num{3}-dimensionalen Weltkoordinatensystem (Arbeitsraum).
			\item \emph{Bahn-/Trajektorien-Planungsproblem} \\ Die Bestimmung einer Bahn/Trajektorie von Anfangs-RAN zu End-RAN (in der Regel im Konfigurationsraum), sodass der Roboter nicht mit Hindernissen kolidiert und die geplante Bewegung möglichst konsistent mit den kinematischen und kinetischen Beschränkungen des Roboters ist.
		\end{itemize}
		Meistens sind viele, alternative Bahnen von Start zum Ziel möglich. Die Auswahl einer optimalen Bahn kann zum Beispiel durch die Minimierung von Kosten (\zB Verfahrzeit, Bahnlänge, Energieaufwand, \dots) unter der Berücksichtigung von Beschränkungen (Kollisionsvermeidung, Sicherheit, Möglichkeit guter Sensordatenaufnahme, \dots) bestimmt werden. Ideal sind hierzu "Anytime"-Algorithmen, in der Realität erfordert die (optimale) Bahnplanung jedoch hohe Rechenzeiten. Daher werden oft Heuristiken verwendet, um die Echtzeitanforderungen einzuhalten.
		
		\begin{figure}
			\centering
			\begin{tikzpicture}[every node/.style = { draw, rectangle, align = center, minimum width = 5cm }]
				\node (a) {Auftragseingang};
				\node [below = 1 of a] (b) {Aufgabenplanung};
				\node [below = 1 of b] (c) {Topologische Wegplanung};
				\node [below = 1 of c] (d) {Geometrische Wegplanung};
				\node [below = 1 of d] (e) {Kinematische \\ Trajektorienplanung};
				\node [below = 1 of e] (f) {Kinetische \\ Trajektorienplanung};
				\node [below = 1 of f] (g) {Bahnfolgeregelung};
				\node [right = 1 of g] (h) {Externe Sensordaten: \\ Aufnahme und Verarbeitung};
				\node [right = 1 of d] (i) {Weltmodell(e)};
				\coordinate [left = 0.5 of i] (j);
				\node [left = 1 of f] (k) {
					\begin{minipage}{5.2cm}
						Kollisionsvermeidung, z.\,B.:
						\begin{enumerate}
							\item Kollisionsdetektion
							\item Konsequenzen, z.\,B.:
								\begin{itemize}
									\item Sofort Anhalten
									\item Hindernis umfahren
									\item Weg versperrt
								\end{itemize}
						\end{enumerate}
					\end{minipage}
				};
				\coordinate (l) at (-4.3, -9.55);
				\path (k) -- coordinate(m) (f);
				\path let \p1 = (l), \p2 = (m) in coordinate (n) at (\x2, \y1);
				
				\draw [->] (a) -- (b);
				\draw [->] (b) -- (c);
				\draw [->] (c) -- (d);
				\draw [->] (d) -- (e);
				\draw [->] (e) -- (f);
				\draw [->] (f) -- (g);
				\draw [->] (g) -- (h);
				\draw [->] (h) -- (i);
				\draw [->] (i) -- (j) |- (c);
				\draw [->] (i) -- (j) |- (d);
				\draw [->] (i) -- (j) |- (e);
				\draw [->] (i) -- (j) |- (f);
				\draw [->] (l) -- (n) |- (g);
				\draw [->] (k) |- (c);
				\draw [->] (k) |- (d);
				\draw [->, dashed] (i) to[bend right, in = 205, out = 10] (k);
				\draw [->, dashed] (h) to[bend left, in = 160, out = 10] (k.south east);
			\end{tikzpicture}
			\caption{Hierarchische Auftragsbearbeitung und Planung.}
			\label{fig:job_processing_and_planning}
		\end{figure}

		\section{Bahnplanungsarten}
			Tabelle~\ref{tab:path_planning_types} zeigt die unterschiedlichen Arten der Bahnplanung auf. Dabei ist zu beachten, dass viele der im Folgenden betrachteten Verfahren ein (nahezu) perfektes Weltmodell voraussetzen. In der Praxis sind jedoch zusätzlich die Unsicherheiten und Eigenschaften der Sensorik sowie die Echtzeitanforderungen eine große Rolle.
			
			\begin{table}
				\centering
				\begin{tabular}{l|p{6cm}|p{4cm}}
					\textbf{Art/Ebene der Bahnplanung} & \textbf{Umweltmodell}                                           & \textbf{Robotermodell}      \\ \hline
					Topologische Wegplanung            & Global (2D): Graph                                              & Punkt                       \\ \hline
					Geometrische Bahnplanung           & Global (2D, 3D): Zellzerlegung, Voronoi-Diagramm, Potentialfeld & Punkt, \ggf mit Ausdehnung  \\ \hline
					Kinematische Trajektorienplanung   & Lokal (3D, 4D): \newline Nichtlineare Optimierung               & Kinematisches Robotermodell \\ \hline
					Kinetische Trajektorienplanung     & Lokal (4D): \newline Dynamische Optimierung                     & Kinetisches Robotermodell
				\end{tabular}
				\caption{Arten der Bahnplanung, wobei die Verfahren absteigend von globalen und grob granularen zu lokalen und fein granularen Verfahren sortiert sind.}
				\label{tab:path_planning_types}
			\end{table}
		% end

		\section{Topologische Wegplanung}
			Die \emph{topologischen Wegplanung} basiert auf einer Abstraktion der Umgebung in Form diskreter Orte mit verbindenden Kanten. Oftmals wird dies als kantengewichteter (\ggf gerichteter) Graph dargestellt.
			
			Zur Wegplanung wird ein Startknoten \(K_1\) und ein Zielknoten \(K_\text{Ziel}\) angegeben und der günstigste Weg vom Start- zum Zielknoten bestimmt (\zB mit dem Dijkstra- oder A*-Algorithmus). Eine größeres Kantengewicht bedeutet z.\,B., dass
			\begin{itemize}
				\item die Passage schwieriger zu passieren ist,
				\item die Durchfahrt mehr Zeit benötigt (\zB da sie länger ist oder hoch frequentiert) oder
				\item die Kante häufig versperrt ist.
			\end{itemize}
			Es ist möglich, die Kantengewichte adaptiv aus den Erfahrungswerten des Roboters anzupassen.
		% end

		\section{Bahnplanung im Arbeitsraum vs. Bahnplanung im Konfigurationsraum}
			Der Arbeitsraum eines Roboters ist eine Teilmenge des 2- oder 3-dimensionalen kartesischen Raums, wobei Hindernisse durch einfache Hüllen (Kugel, Ellipsoide, Polygone, \dots) approximiert werden. Dabei werden Hindernisse oftmals virtuell vergrößert, sodass die Ausdehnung des Roboters auf einen Punkt reduziert werden kann (dies erleichtert die Bahnplanung, kann jedoch einige Bahnen anscheinend unmöglich machen, auch wenn diese möglich wären).
			\begin{itemize}
				\item \textbf{Vorteil:} Der kartesische Arbeitsraum ist intuitiv verständlich.
				\item \textbf{Nachteile:}
					\begin{itemize}
						\item Unerreichbare Zwischenpunkte der geplanten Bahn sind schwerer zu detektieren (die gesamte Bahn muss im erreichbaren Arbeitsraum liegen).
						\item In der Nähe kinematischer Singularitäten werden hohe Geschwindigkeiten geplant, was bei Gelenkbeschränkungen zu Bahnabweichungen führt.
						\item Möglicherweise sind Start- oder Ziel-RAN mit unterschiedlichen Gelenkstellungen erreichbar.
					\end{itemize}
			\end{itemize}
			Aufgrund dieser vielen Nachteile wird Bahnplanung und -interpolation im Konfigurationsraum (Gelenkraum) präferiert. Dies führt bei mehr als drei DOF jedoch zu einem hochdimensionalen Planungsraum.
			
			Definition: Der \emph{Konfigurationsraum} bezeichnet die Abbildung des (erreichbaren) Arbeitsraum in den Raum aller möglichen Gelenkkonfigurationen unter Berücksichtigung der
			\begin{itemize}
				\item Arbeitsraumsituation (Hindernisse, Begrenzungen, \dots),
				\item räumlicher Ausdehnung des Roboters und
				\item Kinematikmodell des Roboters.
			\end{itemize}
			Für mobile Roboter sind häufig Teilmengen des Arbeits- und Konfigurationsraumes identisch (\zB in der 2-dimensionalen Ebene).
		% end

		\section{Geometrische Bahnplanung}
			\subsection{Metrische Darstellung}
				Die geometrische Bahnplanung basiert auf einer metrischen Darstellung des Raumes. Dies sind diskrete, räumliche Zerlegung des Raumes selbst anstelle der Objekte im Raum. Dieser metrische Raum ist dabei aus elementaren geometrischen 2- oder 3-dimensionalen Körpern (Punkte, Polygone, Kreise; Würfel, Ellipsoide) aufgebaut.
				
				Eigenschaften:
				\begin{itemize}
					\item Menge von elementaren Grundkörpern zur Beschreibung der Objekte verwendet.
					\item Menge von Zusammensetzungs- und Verformungsoperatoren zur Manipulation von Objekten.
				\end{itemize}
			
				Probleme:
				\begin{itemize}
					\item Stabilität: Kleine Variationen in der Eingabe können zu einer drastischen Veränderung der Darstellung führen. Daher müssen Methoden zur Dämpfung von Schwankungen eingesetzt werden.
					\item Eindeutigkeit: Verschiedene Umgebungen können die gleiche geometrische Darstellung haben.
					\item Darstellungsmöglichkeiten: Besondere Eigenschaften der Umwelt sind \mglw nur mangelhaft darstellbar.
				\end{itemize}
			% end

			\subsection{Roadmap-Verfahren} 
				Bei \emph{Roadmap-Verfahren} werden Verbindungen zwischen Freiräumen im Konfigurationsraum dargestellt (durch ein Netzwerk von eindimensionalen Kurven), was eine "Straßenkarte" \(R\) produziert. Die Bahnplanung erfordert dann die
				\begin{itemize}
					\item Identifikation der Anfangs- und Endkonfiguration mit Knoten in \(R\) sowie das
					\item Suchen eines geeigneten Verbindungspfades in \(R\).
				\end{itemize}
				
				Es gibt verschiedene Verfahren zur Erzeugung von \(R\):
				\begin{itemize}
					\item Sichtbarkeitsgraphen
					\item Tangentengraphen
					\item Voronoi-Diagramme
					\item Sonstige: Freeway Nets, Silhouettes
				\end{itemize}

				\subsubsection{Sichtbarkeitsgraph}
					\textbf{Ansatz:} Der Sichtbarkeitsgraph wird erzeugt aus der Verbindung zwischen allen Eckpunkten der Hindernisse sowie von Start- und Endkonfiguration, wobei die Verbindungen im freien Konfigurationsraum liegen müssen. \\
					\textbf{Bahnplanung:} Bestimmung des kürzesten Verbindungsweges vom Start- zum Zielknoten.
					
					Abbildung~\ref{fig:visibility_graph} zeigt einen beispielhaften Sichtbarkeitsgraph im Konfigurationsraum.
					
					\begin{figure}
						\centering
						\begin{tikzpicture}
							\node [fill = black, draw, circle, label = left:Start] (S) at (-1, 0) {};
							\node [fill = black, draw, circle, label = right:Ziel] (G) at (9, -3) {};
							
							\coordinate (a1) at (1, -1);
							\coordinate (a2) at (2, 1);
							\coordinate (a3) at (3.5, -1.5);
							
							\coordinate (b1) at (4, -4);
							\coordinate (b2) at (6, 0);
							\coordinate (b3) at (6.5, -3);
							
							\coordinate (c1) at (4, 2);
							\coordinate (c2) at (4.5, 3);
							\coordinate (c3) at (6, 2.9);
							\coordinate (c4) at (5.5, 2.2);
							
							\coordinate (d1) at (-3, 4);
							\coordinate (d2) at (12, 4);
							\coordinate (d3) at (11, -5);
							\coordinate (d4) at (-4, -5);
							
							\draw [fill = black] (a1) -- (a2) -- (a3) -- cycle;
							\draw [fill = black] (b1) -- (b2) -- (b3) -- cycle;
							\draw [fill = black] (c1) -- (c2) -- (c3) -- (c4) -- cycle;
							
							\draw [line width = 4pt] (d1) -- (d2) -- (d3) -- (d4) -- cycle;
							
							\draw (a1) -- (b1);
							\draw (a2) -- (b2);
							\draw (a2) -- (c1);
							\draw (a2) -- (c2);
							\draw (a2) -- (c4);
							\draw (a3) -- (b1);
							\draw (a3) -- (b2);
							\draw (a3) -- (c1);
							\draw (a3) -- (c4);
							
							\draw (b1) -- (c1);
							\draw (b1) -- (c3);
							\draw (b1) -- (c4);
							\draw (b2) -- (c1);
							\draw (b2) -- (c3);
							\draw (b2) -- (c4);
							
							\draw [dashed] (S) -- (a1);
							\draw [dashed] (S) -- (a2);
							\draw [dashed] (S) -- (b1);
							\draw [dashed] (S) -- (c1);
							\draw [dashed] (S) -- (c2);
							
							\draw [dashed] (G) -- (b1);
							\draw [dashed] (G) -- (b2);
							\draw [dashed] (G) -- (b3);
							\draw [dashed] (G) -- (c3);
							\draw [dashed] (G) -- (c4);
						\end{tikzpicture}
						\caption{Sichtbarkeitsgraph mit Start- und Zielknoten im beschränkten Konfigurationsraum, wobei die schwarzen Flächen Hindernisse darstellen. Zur Vereinfachung wurden die Verbindungen zum Konfigurationsraumrand weggelassen.}
						\label{fig:visibility_graph}
					\end{figure}
				% end

				\subsubsection{Tangentengraph}
					Der Sichtbarkeitsgraph enthält sehr viel mehr Informationen, als nötig sind (für je zwei Hindernisse sind nur die kotangenten Verbindungen zwischen vier Eckpunkten relevant). Bei einem \emph{Tangentengraph} werden nur diese Verbindungen betrachtet, \dh der Sichtbarkeitsgraph wird auf diese reduziert.
				% end

				\subsubsection{Voronoi-Diagramme}
					Eine Schwierigkeit bei Sichtbarkeitsgraphen ist, dass resultierende Bahnen meistens nahe an Hindernissen vorbei gehen, diese sogar berühren können. Daher sind die durch Sichtbarkeitsgraphen generierten Bahnen nur "semi-frei". Einen alternativen Ansatz verfolgen \emph{Voronoi-Diagramme}, bei denen die Bahnen so weit wie möglich von den nächsten Hindernissen entfernt liegen. Diese werden konstruiert, indem die Wege entlang der Punkte gelegt werden, die den gleichen Abstand zu den nächsten Hindernissen haben (wobei der Rand des Arbeitsbereichs als Hindernis zählt). Dadurch haben die Bahnen immer den maximalen Abstand zu den festen Hindernissen.
					
					\textbf{Bahnplanung:} Für die Bahnplanung bewegt sich der Roboter zunächst orthogonal zum Voronoi-Diagramm auf dieses zu und bewegt sich anschließend entlang dem Diagramm zum "Absprungpunkt" zum Ziel. Dieser liegt so, dass der Roboter wieder orthogonal zum Diagramm auf das Ziel zubewegt.
					
					\textbf{Nachteile:}
					\begin{itemize}
						\item Die berechneten Bahnen sind im Vergleich zum Sichtbarkeitsgraphen sehr lang.
						\item Eckige Bahnen, die nur mit Korrekturen in einer kontinuierlichen Bewegung umsetzbar sind.
					\end{itemize}
				% end
			% end

			\subsection{Exakte Zellzerlegung}
				\textbf{Ansatz:} Zerlegung des freien Konfigurationsraums in eine Menge an nicht überlappenden, konvexen Gebieten (Zellen), deren Vereinigung genau den freien Konfigurationsraum ergibt. Über die benachbarten Zellen wird dann der Verbindungsgraph (Freiraumgraph) konstruiert. Abbildung~\ref{fig:connection_graph} zeigt eine solche Zellzerlegung. \\
				\textbf{Bahnplanung:} Zur Bahnplanung wird ein \emph{Kanal} von der Zelle mit Start zur Zelle mit Ziel konstruiert. Aus diesem Kanal wird anschließend eine Bahn konstruiert, \bspw durch Verbinden der Mittelpunkte der Ränder von benachbarten Zellen.
				
				\begin{figure}
					\centering
					\begin{tikzpicture}
						\node [fill = black, draw, circle, label = left:Start] (S) at (-1, 0) {};
						\node [fill = black, draw, circle, label = right:Ziel] (G) at (9, -3) {};
						
						\coordinate (a1) at (1, -1);
						\coordinate (a2) at (2, 1);
						\coordinate (a3) at (3.5, -1.5);
						
						\coordinate (b1) at (4, -4);
						\coordinate (b2) at (6, 0);
						\coordinate (b3) at (6.5, -3);
						
						\coordinate (c1) at (4, 2);
						\coordinate (c2) at (4.5, 3);
						\coordinate (c3) at (6, 2.9);
						\coordinate (c4) at (5.5, 2.2);
						
						\coordinate (d1) at (-3, 4);
						\coordinate (d2) at (12, 4);
						\coordinate (d3) at (11, -5);
						\coordinate (d4) at (-4, -5);
						
						\draw [fill = black] (a1) -- (a2) -- (a3) -- cycle;
						\draw [fill = black] (b1) -- (b2) -- (b3) -- cycle;
						\draw [fill = black] (c1) -- (c2) -- (c3) -- (c4) -- cycle;
						
						\draw [line width = 4pt] (d1) -- (d2) -- (d3) -- (d4) -- cycle;
						
						\draw (a1) -- (d4);
						\draw (a2) -- (d1);
						\draw (a2) -- (c1);
						\draw (a3) -- (b1);
						\draw (a3) -- (b2);
						\draw (a3) -- (c4);
						
						\draw (b1) -- (d3);
						\draw (b1) -- (d4);
						\draw (b2) -- (c4);
						\draw (b2) -- (d2);
						\draw (b3) -- (d3);
						
						\draw (c2) -- (d1);
						\draw (c3) -- (d2);
					\end{tikzpicture}
					\caption{Zellzerlegung mit Start- und Zielknoten im beschränkten Konfigurationsraum, wobei die schwarzen Flächen Hindernisse darstellen.}
					\label{fig:connection_graph}
				\end{figure}
			
				\subsubsection{Trapez-Zerlegung}
					Der Aufwand einer solchen konvexen, optimalen Zellzerlegung ist mindestens polynomial in der Anzahl der Polygonecken der Zerlegung. Eine einfachere Variante stellt die \emph{Trapez-Zerlegung} dar.
					
					Dabei wird eine vertikale Linie (\bzw Hyper-Ebene) von links nach rechts durch den Konfigurationsraum geschoben. Schneidet sich die Linie mit einem Eckpunkt, so wird eine Gerade vom Schnittpunkt zum Rand, \bzw bis zum nächsten Hindernis erzeugt. Dies führt zu einer Zerlegung in trapezförmige oder dreieckige Zellen.
					
					Die Bahnplanung funktioniert dann wie bei einer optimalen Zellzerlegung.
					
					\begin{figure}
						\centering
						\begin{tikzpicture}
							\node [fill = black, draw, circle, label = left:Start] (S) at (-1, 0) {};
							\node [fill = black, draw, circle, label = right:Ziel] (G) at (9, -3) {};
							
							\coordinate (a1) at (1, -1);
							\coordinate (a2) at (2, 1);
							\coordinate (a3) at (3.5, -1.5);
							
							\coordinate (b1) at (4, -4);
							\coordinate (b2) at (6, 0);
							\coordinate (b3) at (6.5, -3);
							
							\coordinate (c1) at (4, 2);
							\coordinate (c2) at (4.5, 3);
							\coordinate (c3) at (6, 2.9);
							\coordinate (c4) at (5.5, 2.2);
							
							\coordinate (d1) at (-3, 4);
							\coordinate (d2) at (12, 4);
							\coordinate (d3) at (11, -5);
							\coordinate (d4) at (-4, -5);
							
							\draw [fill = black] (a1) -- (a2) -- (a3) -- cycle;
							\draw [fill = black] (b1) -- (b2) -- (b3) -- cycle;
							\draw [fill = black] (c1) -- (c2) -- (c3) -- (c4) -- cycle;
							
							\draw [line width = 4pt] (d1) -- (d2) -- (d3) -- (d4) -- cycle;
							
							\draw (-3, 4) -- (-3, -5);
							\draw (1, 4) -- (1, -5);
							\draw (2, 4) -- (2, 1);
							\draw (3.5, 4) -- (3.5, -5);
							\draw (4, 4) -- (4, -5);
							\draw (4.5, 4) -- (4.5, 3);
							\draw (6, 4) -- (6, 0);
							\draw (6.5, 4) -- (6.5, -5);
							\draw (11, 4) -- (11, -5);
						\end{tikzpicture}
						\caption{Trapez-Zerlegung mit Start- und Zielknoten im beschränkten Konfigurationsraum, wobei die schwarzen Flächen Hindernisse darstellen.}
						\label{fig:connection_graph_trapeze}
					\end{figure}
				% end
			% end

			\subsection{Approximative Zellzerlegung}
				Ein Vorteil der Zellzerlegung liegt darin, dass lokale Änderungen der Umwelt nur lokale Änderungen der Repräsentation (im Unterschied zum Roadmap-Verfahren). Bei der exakten Zellzerlegung ergibt die Vereinigung der Zellen exakt den Freiraum. Eine approximative Zellzerlegung
				\begin{itemize}
					\item verwendet nur Zellen fester, vorgegebener Größe(n),
					\item die Vereinigung der Zellen ist eine Teilmenge des Freiraums und
					\item der Rand einer Zelle hat meistens keine physikalische Bedeutung.
				\end{itemize}
				Wie in Abbildung~\ref{fig:approx_cell_decomposition} wird der Raum rekursiv in immer vier gleich Große Zellen zerlegt. Daraus kann ein Quadtree erstellt werden, dessen Knoten die folgenden Werte haben können:
				\begin{itemize}
					\item Nur Freiraum:  \tabto{3cm} \whiteBox
					\item Nur Hindernis: \tabto{3cm} \blackBox
					\item Gemischt:      \tabto{3cm} \grayBox
				\end{itemize}
				Der Raum wird solange weiter zerlegt, bis die maximale Auflösung erreicht wurde. Die Knoten werden dabei in der Reihenfolge
				\begin{table}[H]
					\centering
					\begin{tabular}{|c|c|}
						\hline
						\num{1} & \num{2} \\ \hline
						\num{3} & \num{4} \\ \hline
					\end{tabular}
				\end{table}
				von links nach rechts gelistet. Abbildung~\ref{fig:approx_cell_decomposition_quadtree} zeigt den Quadtree des vierten Quadranten der approximativen Zerlegung aus Abbildung~\ref{fig:approx_cell_decomposition}.
				
				Das Verfahren lässt sich analog auf einen 3- oder \(n\)-dimensionalen Raum anwenden.
			
				\begin{figure}
					\centering
					\begin{tikzpicture}
						\coordinate (a1) at (1, -1);
						\coordinate (a2) at (2, 1);
						\coordinate (a3) at (3.5, -1.5);
						
						\coordinate (b1) at (4, -4);
						\coordinate (b15) at (5, 0);
						\coordinate (b2) at (6.5, 1);
						\coordinate (b3) at (6.5, -3);
						
						\coordinate (c1) at (4, 2);
						\coordinate (c2) at (4.5, 3);
						\coordinate (c3) at (6, 2.9);
						\coordinate (c4) at (5.5, 2.2);
						
						\coordinate (d1) at (-1, 5);
						\coordinate (d2) at (9, 5);
						\coordinate (d3) at (9, -5);
						\coordinate (d4) at (-1, -5);
						
						\draw [fill = black] (a1) -- (a2) -- (a3) -- cycle;
						\draw [fill = black] (b1) -- (b15) -- (b2) -- (b3) -- cycle;
						\draw [fill = black] (c1) -- (c2) -- (c3) -- (c4) -- cycle;
						
						\draw [line width = 4pt] (d1) -- (d2) -- (d3) -- (d4) -- cycle;
						
						\draw [color = tud3b, line width = 3pt, step = 5, xshift = -1cm] (d1) grid +(10, -10);
						\draw [color = tud3b, line width = 2pt, step = 2.5, xshift = -1cm] (d1) grid +(10, -10);
						\draw [color = tud3b, line width = 1pt] (0.25, 0) -- (0.25, -2.5);
						\draw [color = tud3b, line width = 1pt] (2.75, 2.5) -- (2.75, -2.5);
						\draw [color = tud3b, line width = 1pt] (5.25, 5) -- (5.25, -5);
						\draw [color = tud3b, line width = 1pt] (-1, -1.25) -- (6.5, -1.25);
						\draw [color = tud3b, line width = 1pt] (4, -3.75) -- (6.5, -3.75);
						\draw [color = tud3b, line width = 1pt] (1.5, 1.25) -- (6.5, 1.25);
						\draw [color = tud3b, line width = 1pt] (4, 3.75) -- (6.5, 3.75);
					\end{tikzpicture}
					\caption{Approximative Zellzerlegung im beschränkten Konfigurationsraum, wobei die schwarzen Flächen Hindernisse darstellen.}
					\label{fig:approx_cell_decomposition}
				\end{figure}
			
				\begin{figure}
					\Tree[.{\grayBox}
						[.{\grayBox}
							{\grayBox}
							{\blackBox}
							{\grayBox}
							{\blackBox}
						]
						{\whiteBox}
						[.{\grayBox}
							{\grayBox}
							{\grayBox}
							{\grayBox}
							{\whiteBox}
						]
						{\whiteBox}
					]
					\caption{Quadtree des vierten Quadranten der approximativen Zerlegung aus Abbildung~\ref{fig:approx_cell_decomposition}.}
					\label{fig:approx_cell_decomposition_quadtree}
				\end{figure}
			% end

			\subsection{Potentialfeld-Methoden} % 7.50, 7.51, 7.52, 7.53, 7.54, 7.55, 7.56
				Zerlegungs-Verfahren beruhen auf der Suche in einem diskreten (\bzw diskretisierten) Raum. Eine alternative sind Heuristiken zur (lokalen) Suche in einem kontinuierlichem Raum.
				
				Bei \emph{Potentialfeld-Methoden} werden Objekte als geladene, punktförmige Teilchen betrachtet, wobei das
				\begin{itemize}
					\item Ziel \( \vec{q}_\text{Ziel} \) ein anziehendes Potential \( U_\text{Ziel} \) hat und
					\item Hindernisse ein abstoßendes Potential \( U_\text{Hindernis} \) haben.
				\end{itemize}
				Daraus ergibt für jede Konfiguration \( \vec{q} \) ein Potential \(U\):
				\begin{equation*}
					U(\vec{q}) = U_\text{Ziel}(\vec{q}) + \sum U_\text{Hindernis}(\vec{q})
				\end{equation*}
				Auf den Roboter wirkt dann eine fiktive Anziehungskraft als Gradient des Potentialfelds:
				\begin{equation*}
					\vec{F}(\vec{q}) = -\vec{\nabla} U(\vec{q}) =
						- \begin{bmatrix}
							\partial U / \partial q_1 \\
							\vdots \\
							\partial U / \partial q_n
						\end{bmatrix}
				\end{equation*}
				Dies entspricht dem Verfahren des steilsten Abstiegs (Steepest Descent) zur Minimierung des Gesamtpotentials.
				
				\paragraph{Berechnung}
					Es sind viele verschiedene Definitionen der Potentiale möglich, z.\,B.:
					\begin{align*}
						U_\text{Ziel}(\vec{q}) &\coloneqq \alpha \cdot \text{dist}(\vec{q}, \text{Ziel})^2 \\
						U_\text{Hindernis}(\vec{q}) &\coloneqq \frac{\beta}{\beta_0 + \text{dist}(\vec{q}, \text{Hindernis})}
					\end{align*}
					mit geeigneten zu wählenden Parametern \( \alpha, \beta, \beta_0 > 0 \), wobei \( \beta_0 \) die Potentialhöhe der Hindernisse festlegt (\( \beta_0 = 0 \) entspricht einem unendlichen Potential, \dh einer Barriere). \( \text{dist}(\vec{q}, \text{Hindernis}) \) entspricht dem minimalen Abstand des Punktes zum Hindernis, wobei "Null" bedeutet, dass der Punkt im Hindernis liegt.
					
					Für \( U_\text{Hindernis}(\vec{q}) \) gibt es unterschiedliche Berechnungsvarianten, z.\,B.:
					\begin{itemize}
						\item nur zum nächsten Hindernis oder
						\item summiert über alle Hindernisse (in der Nähe).
					\end{itemize}
				% end
				
				\paragraph{Diskussion}
					\begin{itemize}
						\item \textbf{Vorteile:}
							\begin{itemize}
								\item Einfache Algorithmen.
								\item Glatte Bahnformen.
								\item Online einsetzbar, \dh die Planung mit aktuellen Sensordaten ist in Echtzeit mit der Regelung koppelbar.
							\end{itemize}
						\item \textbf{Nachteil:}
							\begin{itemize}
								\item Die Gefahr, in lokalen Minima hängen zu bleiben, ist groß.
							\end{itemize}
					\end{itemize}
				
					Abhilfen \bzgl der lokalen Minima sind z.\,B.:
					\begin{itemize}
						\item Konstruktion eines Potentials ohne lokales Minima, \zB über Strömungsmodelle (hohe Rechenzeiten).
						\item Erhöhung des Abstoßungspotentials in einer Region, in der ein lokales Minima erkannt wurde (dieses als Hindernis markieren).
						\item Kopplung der lokalen Potentialfeld-Methode mit einem globalen Verfahren:
							\begin{itemize}
								\item Randomisierte Bahnplaner (entkommen aus den Minima durch stochastische Suche).
								\item Verwendung von globalen Zellzerlegungs-Verfahren zur Generierung einer Ausgangsbahn.
							\end{itemize}
					\end{itemize}
				% end
			% end

			\subsection{Komplexität der geometrischen Bahnplanung}
				Eine obere Schranke der Komplexität der (globalen) Bahnplanung im Konfigurationsraum wurde von Schwartz und Sharir im Jahre 1983 gefunden:
				\begin{itemize}
					\item Die Komplexität des Problems wächst (vermutlich immer) exponentiell in der Anzahl der Roboterfreiheitsgrade.
					\item Wenn es schnellere Algorithmen geben sollte, so benötigen diese mindestens polynomiale Zeit \bzgl \(n\).
				\end{itemize}
			
				Anmerkungen:
				\begin{itemize}
					\item In Spezialfällen mit besonderen Geometrien kann die Komplexität niedriger sein.
					\item Im Allgemeinen wächst die Komplexität weiter an, wenn sich die Hindernisse bewegen und/oder Unsicherheiten berücksichtigt werden.
					\item Alle gängigen Bahnplanungsverfahren sind "unvollständig" \bzw beruhen auf Heuristiken oder Diskretisierungen.
				\end{itemize}
			% end

			\subsection{Stichprobenverfahren}
				Ein Stichprobenverfahren zur Erstellung einer \emph{Probabilistic Roadmap} (PRM) besteht aus folgenden Schritten:
				\begin{enumerate}
					\item Generieren von zufälligen Stichproben von Konfigurationen (Abbildung~\ref{fig:prm_step1}).
					\item Entfernen von Stichproben im verbotenem Bereich (Abbildung~\ref{fig:prm_step2}).
					\item Verbinden jeder Stichproben mit den \(k\) nächsten (noch nicht verbundenen) Nachbarn (Abbildung~\ref{fig:prm_step3}).
					\item Entfernen von allen Verbindungen, die durch eine verbotene Region gehen (Abbildung~\ref{fig:prm_step4}).
				\end{enumerate}
				Der daraus entstehende (\mglw nicht-planare) Graph ist eine "probabilistische Straßenkarte" (Probabilistic Roadmap, PRM) (Abbildung~\ref{fig:prm_step5}). Die Bahnplanung kann dann unter Verwendung von Graphenalgorithmen (\zB A*) stattfinden.

				\begin{figure}
					\centering
					\begin{tikzpicture}
						\coordinate (a1) at (1, -1);
						\coordinate (a2) at (2, 1);
						\coordinate (a3) at (3.5, -1.5);
						
						\coordinate (b1) at (4, -4);
						\coordinate (b2) at (6, 0);
						\coordinate (b3) at (6.5, -3);
						
						\coordinate (c1) at (4, 2);
						\coordinate (c2) at (4.5, 3);
						\coordinate (c3) at (6, 2.9);
						\coordinate (c4) at (5.5, 2.2);
						
						\coordinate (d1) at (-1, 4);
						\coordinate (d2) at (9, 4);
						\coordinate (d3) at (9, -5);
						\coordinate (d4) at (-1, -5);
						
						\draw [fill = black] (a1) -- (a2) -- (a3) -- cycle;
						\draw [fill = black] (b1) -- (b2) -- (b3) -- cycle;
						\draw [fill = black] (c1) -- (c2) -- (c3) -- (c4) -- cycle;
						
						\draw [line width = 4pt] (d1) -- (d2) -- (d3) -- (d4) -- cycle;
						
						\node [draw, circle, fill = white] (a) at (0, 1) {};
						\node [draw, circle, fill = white] (b) at (4, 2) {};
						\node [draw, circle, fill = white] (c) at (7, -4) {};
						\node [draw, circle, fill = white] (d) at (5, 2) {};
						\node [draw, circle, fill = white] (e) at (3, 1) {};
						\node [draw, circle, fill = white] (f) at (3, -2) {};
						\node [draw, circle, fill = white] (g) at (7, -5) {};
						\node [draw, circle, fill = white] (h) at (4, -2) {};
						\node [draw, circle, fill = white] (i) at (8, -5) {};
						\node [draw, circle, fill = white] (j) at (9, -4) {};
						\node [draw, circle, fill = white] (k) at (1, -4) {};
						\node [draw, circle, fill = white] (l) at (9, 0) {};
						\node [draw, circle, fill = white] (m) at (5, 0) {};
						\node [draw, circle, fill = white] (n) at (8, -4) {};
						\node [draw, circle, fill = white] (o) at (5, 4) {};
						\node [draw, circle, fill = white] (p) at (7, 1) {};
						\node [draw, circle, fill = white] (q) at (1, 3) {};
						\node [draw, circle, fill = white] (r) at (1, -3) {};
						\node [draw, circle, fill = white] (s) at (5, 3) {};
						\node [draw, circle, fill = white] (t) at (3, -5) {};
					\end{tikzpicture}
					\caption{Probabilistic Roadmap, Schritt 1: Zufällige Stichproben von Konfigurationen.}
					\label{fig:prm_step1}
				\end{figure}
				\begin{figure}
					\centering
					\begin{tikzpicture}
						\coordinate (a1) at (1, -1);
						\coordinate (a2) at (2, 1);
						\coordinate (a3) at (3.5, -1.5);
						
						\coordinate (b1) at (4, -4);
						\coordinate (b2) at (6, 0);
						\coordinate (b3) at (6.5, -3);
						
						\coordinate (c1) at (4, 2);
						\coordinate (c2) at (4.5, 3);
						\coordinate (c3) at (6, 2.9);
						\coordinate (c4) at (5.5, 2.2);
						
						\coordinate (d1) at (-1, 4);
						\coordinate (d2) at (9, 4);
						\coordinate (d3) at (9, -5);
						\coordinate (d4) at (-1, -5);
						
						\draw [fill = black] (a1) -- (a2) -- (a3) -- cycle;
						\draw [fill = black] (b1) -- (b2) -- (b3) -- cycle;
						\draw [fill = black] (c1) -- (c2) -- (c3) -- (c4) -- cycle;
						
						\draw [line width = 4pt] (d1) -- (d2) -- (d3) -- (d4) -- cycle;
						
						\node [draw, circle, fill = white] (a) at (0, 1) {};
						\node [draw, circle, fill = white] (c) at (7, -4) {};
						\node [draw, circle, fill = white] (e) at (3, 1) {};
						\node [draw, circle, fill = white] (f) at (3, -2) {};
						\node [draw, circle, fill = white] (h) at (4, -2) {};
						\node [draw, circle, fill = white] (k) at (1, -4) {};
						\node [draw, circle, fill = white] (m) at (5, 0) {};
						\node [draw, circle, fill = white] (n) at (8, -4) {};
						\node [draw, circle, fill = white] (p) at (7, 1) {};
						\node [draw, circle, fill = white] (q) at (1, 3) {};
						\node [draw, circle, fill = white] (r) at (1, -3) {};
						\node [draw, circle, fill = tud9b] (b) at (4, 2) {};
						\node [draw, circle, fill = tud9b] (d) at (5, 2) {};
						\node [draw, circle, fill = tud9b] (g) at (7, -5) {};
						\node [draw, circle, fill = tud9b] (i) at (8, -5) {};
						\node [draw, circle, fill = tud9b] (j) at (9, -4) {};
						\node [draw, circle, fill = tud9b] (l) at (9, 0) {};
						\node [draw, circle, fill = tud9b] (o) at (5, 4) {};
						\node [draw, circle, fill = tud9b] (s) at (5, 3) {};
						\node [draw, circle, fill = tud9b] (t) at (3, -5) {};
					\end{tikzpicture}
					\caption{Probabilistic Roadmap, Schritt 2: Entfernung der "verbotenen" Stichproben.}
					\label{fig:prm_step2}
				\end{figure}
				\begin{figure}
					\centering
					\begin{tikzpicture}
						\coordinate (a1) at (1, -1);
						\coordinate (a2) at (2, 1);
						\coordinate (a3) at (3.5, -1.5);
						
						\coordinate (b1) at (4, -4);
						\coordinate (b2) at (6, 0);
						\coordinate (b3) at (6.5, -3);
						
						\coordinate (c1) at (4, 2);
						\coordinate (c2) at (4.5, 3);
						\coordinate (c3) at (6, 2.9);
						\coordinate (c4) at (5.5, 2.2);
						
						\coordinate (d1) at (-1, 4);
						\coordinate (d2) at (9, 4);
						\coordinate (d3) at (9, -5);
						\coordinate (d4) at (-1, -5);
						
						\draw [fill = black] (a1) -- (a2) -- (a3) -- cycle;
						\draw [fill = black] (b1) -- (b2) -- (b3) -- cycle;
						\draw [fill = black] (c1) -- (c2) -- (c3) -- (c4) -- cycle;
						
						\draw [line width = 4pt] (d1) -- (d2) -- (d3) -- (d4) -- cycle;
						
						\node [draw, circle, fill = white] (a) at (0, 1) {a};
						\node [draw, circle, fill = white] (b) at (1, 3) {b};
						\node [draw, circle, fill = white] (c) at (1, -3) {c};
						\node [draw, circle, fill = white] (d) at (1, -4) {d};
						\node [draw, circle, fill = white] (e) at (3, 1) {e};
						\node [draw, circle, fill = white] (f) at (3, -2) {f};
						\node [draw, circle, fill = white] (g) at (4, -2) {g};
						\node [draw, circle, fill = white] (h) at (5, 0) {h};
						\node [draw, circle, fill = white] (i) at (7, -4) {i};
						\node [draw, circle, fill = white] (j) at (7, 1) {j};
						\node [draw, circle, fill = white] (k) at (8, -4) {k};
						
						\draw (a) -- (b);
						\draw (a) -- (e);
					\end{tikzpicture}
					\caption{Probabilistic Roadmap, Schritt 3: Verbinden jeder gültigen Stichprobe mit den \( k = 2 \) nächsten Nachbar.}
					\label{fig:prm_step3}
				\end{figure}
				\begin{figure}
					\centering
					\begin{tikzpicture}
						\coordinate (a1) at (1, -1);
						\coordinate (a2) at (2, 1);
						\coordinate (a3) at (3.5, -1.5);
						
						\coordinate (b1) at (4, -4);
						\coordinate (b2) at (6, 0);
						\coordinate (b3) at (6.5, -3);
						
						\coordinate (c1) at (4, 2);
						\coordinate (c2) at (4.5, 3);
						\coordinate (c3) at (6, 2.9);
						\coordinate (c4) at (5.5, 2.2);
						
						\coordinate (d1) at (-1, 4);
						\coordinate (d2) at (9, 4);
						\coordinate (d3) at (9, -5);
						\coordinate (d4) at (-1, -5);
						
						\draw [fill = black] (a1) -- (a2) -- (a3) -- cycle;
						\draw [fill = black] (b1) -- (b2) -- (b3) -- cycle;
						\draw [fill = black] (c1) -- (c2) -- (c3) -- (c4) -- cycle;
						
						\draw [line width = 4pt] (d1) -- (d2) -- (d3) -- (d4) -- cycle;
						
						\node [draw, circle, fill = white] (a) at (0, 1) {a};
						\node [draw, circle, fill = white] (b) at (1, 3) {b};
						\node [draw, circle, fill = white] (c) at (1, -3) {c};
						\node [draw, circle, fill = white] (d) at (1, -4) {d};
						\node [draw, circle, fill = white] (e) at (3, 1) {e};
						\node [draw, circle, fill = white] (f) at (3, -2) {f};
						\node [draw, circle, fill = white] (g) at (4, -2) {g};
						\node [draw, circle, fill = white] (h) at (5, 0) {h};
						\node [draw, circle, fill = white] (i) at (7, -4) {i};
						\node [draw, circle, fill = white] (j) at (7, 1) {j};
						\node [draw, circle, fill = white] (k) at (8, -4) {k};
						
						\draw (a) -- (b);
						\draw [color = tud9b] (a) -- (e);
						
						\draw (b) -- (e);
						\draw (b) -- (h);
						
						\draw (c) -- (d);
						\draw (c) -- (f);
						
						\draw (d) -- (f);
						\draw (d) -- (g);
						
						\draw (e) -- (h);
						\draw [color = tud9b] (e) -- (f);
						
						\draw (f) -- (g);
						\draw [color = tud9b] (f) -- (h);
						
						\draw [color = tud9b] (g) -- (i);
						\draw [color = tud9b] (g) -- (j);
						
						\draw (h) -- (g);
						\draw (h) -- (j);
						
						\draw (i) -- (k);
						\draw (i) -- (j);
						
						\draw (j) -- (e);
						\draw (j) -- (f);
						
						\draw [color = tud9b] (k) -- (g);
						\draw [color = tud9b] (k) -- (h);
					\end{tikzpicture}
					\caption{Probabilistic Roadmap, Schritt 4: Entfernen der "verbotenen" Verbindungen.}
					\label{fig:prm_step4}
				\end{figure}
				\begin{figure}
					\centering
					\begin{tikzpicture}
						\coordinate (a1) at (1, -1);
						\coordinate (a2) at (2, 1);
						\coordinate (a3) at (3.5, -1.5);
						
						\coordinate (b1) at (4, -4);
						\coordinate (b2) at (6, 0);
						\coordinate (b3) at (6.5, -3);
						
						\coordinate (c1) at (4, 2);
						\coordinate (c2) at (4.5, 3);
						\coordinate (c3) at (6, 2.9);
						\coordinate (c4) at (5.5, 2.2);
						
						\coordinate (d1) at (-1, 4);
						\coordinate (d2) at (9, 4);
						\coordinate (d3) at (9, -5);
						\coordinate (d4) at (-1, -5);
						
						\draw [fill = black] (a1) -- (a2) -- (a3) -- cycle;
						\draw [fill = black] (b1) -- (b2) -- (b3) -- cycle;
						\draw [fill = black] (c1) -- (c2) -- (c3) -- (c4) -- cycle;
						
						\draw [line width = 4pt] (d1) -- (d2) -- (d3) -- (d4) -- cycle;
						
						\node [draw, circle, fill = white] (a) at (0, 1) {a};
						\node [draw, circle, fill = white] (b) at (1, 3) {b};
						\node [draw, circle, fill = white] (c) at (1, -3) {c};
						\node [draw, circle, fill = white] (d) at (1, -4) {d};
						\node [draw, circle, fill = white] (e) at (3, 1) {e};
						\node [draw, circle, fill = white] (f) at (3, -2) {f};
						\node [draw, circle, fill = white] (g) at (4, -2) {g};
						\node [draw, circle, fill = white] (h) at (5, 0) {h};
						\node [draw, circle, fill = white] (i) at (7, -4) {i};
						\node [draw, circle, fill = white] (j) at (7, 1) {j};
						\node [draw, circle, fill = white] (k) at (8, -4) {k};
						
						\draw (a) -- (b);
						
						\draw (b) -- (e);
						\draw (b) -- (h);
						
						\draw (c) -- (d);
						\draw (c) -- (f);
						
						\draw (d) -- (f);
						\draw (d) -- (g);
						
						\draw (e) -- (h);
						
						\draw (f) -- (g);
						
						\draw (h) -- (g);
						\draw (h) -- (j);
						
						\draw (i) -- (k);
						\draw (i) -- (j);
						
						\draw (j) -- (e);
						\draw (j) -- (f);
					\end{tikzpicture}
					\caption{Probabilistic Roadmap, Ergebnis: Der resultierende (nicht-planare) Graph ist die Probabilistic Roadmap (PRM)}
					\label{fig:prm_step5}
				\end{figure}
			
				\paragraph{Allgemeines Vorgehen}
					Das allgemeine Vorgehen von Stichprobenverfahren ist erst die Diskretisierung durch Stichproben und anschließende Graphensuche. Dabei gibt es zwei Kategorien von Graphbasierten Verfahren:
					\begin{itemize}
						\item Informiertes (heuristisches) Suchen
						\item Uninformiertes (blindes) Suchen
					\end{itemize}
					Es ist wichtig, dass die Stichproben "gut" gewählt werden, z.\,B.:
					\begin{itemize}
						\item Gleichförmige Stichprobenverteilung
						\item mehr Stichproben bei Punkten mit wenigen Nachbarn
						\item mehr Stichproben bei Hindernissen
					\end{itemize}
				
					Durch korrekte (zulässige) Heuristiken kann eine enorme Performanzverbesserung erzielt werden. In der Praxis ist die Auswahl solcher Heuristiken jedoch kompliziert\dots
				% end
			% end

			\subsection{Rapidly Exploring Random Trees (RRTs)}
				Siehe Algorithmus~\ref{alg:rrt}.
				
				\begin{algorithm}
					\KwData{\( x_\mathit{init} \), \( K \), \( \Delta t \)}
					\Begin{
						\(\mathcal{T}.\text{init}(x_\mathit{init}) \) \;
						\For{\( k = 1 \) to \( K \)}{
							\( x_\mathit{rand} \gets \text{RANDOM\_STATE}() \) \;
							\( x_\mathit{near} \gets \text{NEAREST\_NEIGHBOR}(x_\mathit{rand}, \mathcal{T}) \) \;
							\( u \gets \text{SELECT\_INPUT}(x_\mathit{rand}, x_\mathit{near}) \) \;
							\( x_\mathit{new} \gets \text{NEW\_STATE}(x_\mathit{near}, u, \Delta t) \) \;
							\( \mathcal{T}.\text{add\_vertex}(x_\mathit{new}) \) \;
							\( \mathcal{T}.\text{add\_edge}(x_\mathit{near}, x_\mathit{new}, u) \) \;
						}
						\Return \(\mathcal{T}\) \;
					}
					\caption{Rapidly Exploring Random Trees}
					\label{alg:rrt}
				\end{algorithm}
			% end

			\subsection{Beispiel: MINERVA}
				MINERVA ist ein Museumstourführungsroboter.
				
				\subsubsection{Umweltmodell: Belegungskarte}
					\begin{itemize}
						\item Die Umgebungskarte wird eingeteilt in ein Netz aus quadratischen Zellen, wobei freie Stellen hell und Hindernisse dunkel markiert werden.
						\item Diese \emph{Belegungskarte} erlernt der Roboter selbstständig (durch Herumfahren).
						\item Die Verknüpfung der beiden Problemstellungen (Aufbau einer Karte und Bestimmung der Position/Orientierung) wird als \emph{SLAM} (Self Localization and Mapping) bezeichnet (siehe Abschnitt~\ref{sec:slam}).
						\item Die Bewegungskarte wird dabei in zwei Schritten aufgebaut:
							\begin{enumerate}
								\item Erfassung von Laser-, Sonar und Odometriedaten.
								\item Fusion der Sensordaten zur Berechnung der Umgebungskarte und der Position/Orientierung des Roboters.
							\end{enumerate}
						\item Die Bahnplanung (mittels Kostenminimierung) erfolgt anschließend auf Basis der Belegungskarte, wobei diese während der Fahrt bei Bedarf neu berechnet wird.
						\item Schwierigkeiten:
							\begin{itemize}
								\item Kürzeste-Wege-Planer sind prinzipiell einsetzbar, allerdings ist in weiten, offenen Umgebung das Versagen der externen Distanzsensoren möglich.
								\item Eine Abhilfe ist, bei der Bahnplanung die für Sensoren günstigen Positionen zu berücksichtigen (\zB nahe am Rand).
							\end{itemize}
					\end{itemize}
				% end

				\subsubsection{"Küstennahe" Bahnplanung}
					Bei der "küstennahen" Bahnplanung wird versucht, den Roboter möglichst nah an Wänden (\bzw Allgemein dem Rand der Karte) zu fahren.
				% end

				\subsubsection{Kollisionsvermeidung (MINERVA)}
					\begin{itemize}
						\item Das Kollisionsvermeidungs-Modul steuert sowohl die momentane Bewegungsrichtung als auch die Geschwindigkeit.
						\item Dabei wird die Roboterkinematik und -dynamik berücksichtigt (Masseträgheiten, maximale und minimale Drehmomente der Radantriebe).
						\item \(\mu\text{DWA}\) (Dynamic Window Algorithm):
							\begin{itemize}
								\item Eingabe: Rohe Abstandsmesswerte (sowohl gemessene als auch simulierte) und Zielposition.
								\item Ausgabe: Sollwert für die lineare und Drehwinkel-Geschwindigkeit.
								\item Berücksichtigung von: harten Beschränkungen (der Roboter muss immer vor dem Aufprall auf ein Hindernis zum Stehen) kommen müssen sowie von weichen Beschränkungen (maximale/minimale Momente, Abstand zum Ziel verringern, Abstand zu Hindernissen groß halten (unterschiedlich Gewichtet)).
							\end{itemize}
					\end{itemize}
				% end
			% end
		% end

		\section{Kinematische und dynamische Trajektorienplanung}
			Bei der kinematischen und dynamischen (kinetischen) Trajektorienplanung werden zusätzlich zu den geometrischen Anforderungen auch die kinematischen \bzw kinetischen Anforderungen des Robotermodells berücksichtigt.

			\subsection{Allgemeine Formulierung}
				Es ist die Systemdynamik
				\begin{equation*}
					\dot{\vec{x}}(t) = \vec{f}\big(\vec{x}(t), \vec{u}(t), t\big) =
						\begin{bmatrix}
							f_1\big(\vec{x}(t), \vec{u}(t), t\big) \\
							\vdots \\
							f_m\big(\vec{x}(t), \vec{u}(t), t\big)
						\end{bmatrix}
				\end{equation*}
				mit den Zustandsvariablen \( \vec{x}(t) = \begin{bmatrix} x_1(t) & \cdots & x_m(t) \end{bmatrix}^T \) und den Steuergrößen \( \vec{u}(t) = \begin{bmatrix} u_1(t) & \cdots & u_l(t) \end{bmatrix}^T \), die bestimmten Steuerbeschränkungen
				\begin{equation*}
					\vec{u}(t) \leq \vec{u}_\mathit{max} \quad\iff\quad
						\begin{matrix}
							u_1(t) \leq u_{1, \mathit{max}} \\
							\vdots \\
							u_l(t) \leq u_{l, \mathit{max}}
						\end{matrix}
				\end{equation*}
				unterliegen. Für Anfangswerte \( \vec{x}(0) \) und Endwerte \( \vec{x}(t_f) \) unterliegt das gesamte System im Zeitraum \( 0 \leq t \leq t_f \) außerdem bestimmten Zustandsbeschränkungen:
				\begin{equation*}
					\vec{g}\big(\vec{x}(t), \vec{u}(t), t\big) \geq \vec{0} \quad\iff\quad
						\begin{matrix}
							g_1\big(\vec{x}(t), \vec{u}(t), t\big) \geq 0 \\
							\vdots \\
							g_n\big(\vec{x}(t), \vec{u}(t), t\big) \geq 0
						\end{matrix}
				\end{equation*}
				
				Das \emph{optimale Steuerungsproblem} (Optimal Control Problem) lässt sich nun durch ein Gütekriterium/eine Kostenfunktion wie folgt definieren
				\begin{equation*}
					\min_{\vec{u}} \> J(\vec{x}, \vec{u}) = \Phi\big(\vec{x}(t_f), t_f\big) + \int_{0}^{t_f} \! L\big(\vec{x}(t), \vec{u}(t), t\big) \dif{t}
				\end{equation*}
				wobei die Kostenfunktion \( J(\vec{x}, \vec{u}) \) in zwei Funktionen \( \Phi \) und \( L \) aufgespalten wird. Beispielhafte Gütekriterien sind:
				\begin{itemize}
					\item Zeitminimalität (\(t_f\) frei):
				\end{itemize}
				\begin{gather*}
					\Phi = t_f,\quad L = 0 \quad\implies\quad \min_{\vec{u}} \> J_t(\vec{x}, \vec{u}) = t_f
				\end{gather*}
				\begin{itemize}
					\item Energieminimalität (\(t_f\) vorgegeben):
				\end{itemize}
				\begin{equation*}
					\Phi = 0,\quad L = \sum_{i = 1}^{l} u_i^2 (t) \quad\implies\quad \min_{\vec{u}} \> J_e(\vec{x}, \vec{u}) = \int_{0}^{t_f} \! \sum_{i = 1}^{l} u_i^2 (t) \dif{t}
				\end{equation*}
				\begin{itemize}
					\item Kombiniertes Kriterium (\(t_f\) frei):
				\end{itemize}
				\begin{equation*}
					\min_{\vec{u}} \> J(\vec{x}, \vec{u}) = \rho_1 \cdot J_t(\vec{x}, \vec{u}) + \rho_2 \cdot J_e(\vec{x}, \vec{u}),\quad \rho_1, \rho_2 > 0
				\end{equation*}
				
				Siehe auch Vorlesung "Optimierung statischer und dynamischer Systeme".
			% end
		% end
	% end

	\chapter{Navigation mobiler Roboter}
		\emph{Navigation} ist die Fähigkeit, den Kurs (die Fahrt) eines mobilen Roboters so zu bestimmen, dass die Umgebung (Land, Wasser, Luft) durchquert und das ziel erreicht ist. Die Aufgabe ist dementsprechend die Bestimmung sowie die Umsetzung einer Bahn (\bzw Trajektorie) vom Start \(S\) zum Ziel \(Z\). Die Navigation besteht dabei aus folgenden Teilaufgaben:
		\begin{itemize}
			\item "Wo bin ich?" \(\to\) dieses Kapitel.
			\item "Wohin bewege ich mich gerade?" (Bahnumsetzung, Echtzeit-Steuerung und -Regelung, Kollisionsvermeidung)
			\item "Wie soll ich zum Ziel gelangen?" (Bahnplanung) \(\to\) Kapitel~\ref{c:bahnplanung}.
			\item "Wo komme ich her?" (Umweltmodelle, Karten) \(\to\) Kapitel~\ref{c:bahnplanung} und Abschnitt~\ref{sec:slam}.
		\end{itemize}

		\section{Lokalisierung und Positionierung}
			Die Positionsbestimmung kann relativ, absolut oder stochastisch erfolgen.
			
			\textbf{Relative Verfahren:}
			\begin{enumerate}
				\item \emph{Odometrie}
					\begin{itemize}
						\item Die Position wird durch "Aufsummieren" des zurückgelegten Weges von der Startposition anhand von Messwerten berechnet.
						\item Vorteil: Rein intern-basiert, \dh es sind keine externen Sensoren nötig.
						\item Nachteil: Ohne Korrekturen wächst der Positionsfehler sehr schnell.
					\end{itemize}
				\item \emph{Inertial-Navigation}
					\begin{itemize}
						\item Die Beschleunigungs- und Rotationsraten werden mit einem Gyroskop gemessen, die aktuelle Position wird durch zweifache Integration über die Messwerte bestimmt (ähnlich zur Odometrie).
						\item Vorteil: Rein intern-basiert, \dh es sind keine externen Sensoren nötig.
						\item Nachteil: Ohne Korrekturen wächst der Drift-Fehler sehr schnell.
					\end{itemize}
				\item[] Werden 1 und 2 kombiniert, so ergibt sich eine \emph{Koppelnavigation}.
			\end{enumerate}
		
			\textbf{Absolute Verfahren:}
			\begin{enumerate} \setcounter{enumi}{2}
				\item \emph{Aktive "Leuchtfeuer"}
					\begin{itemize}
						\item Die Position wird aus Winkel- oder Abstandsmessung zu mindestens drei "Leuchtfeuern" (optisch/Funk) mit bekannten Positionen berechnet (GPS-artig).
						\item Dabei entstehen mehr Messdaten als unbekannte Parameter \(\vec{p}\) (nichtlineares Ausgleichsproblem, siehe Abschnitt~\ref{sec:least_squares}).
					\end{itemize}
				\item \emph{Erkennung künstlicher Landmarken}
					\begin{itemize}
						\item Die Position wird durch die Erkennung von künstlichen "Grenzpfählen" (Formen, Flächen, Farben) an bekannten Positionen berechnet.
					\end{itemize}
				\item \emph{Erkennung natürlicher Landmarken}
					\begin{itemize}
						\item Die Position wird durch Ausnutzen besonderer Eigenschaften der Umwelt berechnet (wie die Erkennung mit künstlichen Landmarken, nur dass die Umwelt nicht modifiziert werden, aber bekannt sein muss).
					\end{itemize}
				\item \emph{Modellvergleich}
					\begin{itemize}
						\item Die aus Sensordaten aufgebaute Karte (Umweltmodell) wird mit einer Referenzkarte verglichen und daraus die Position bestimmt.
					\end{itemize}
			\end{enumerate}
		
			\textbf{Stochastische Verfahren:}
			\begin{enumerate} \setcounter{enumi}{6}
				\item \emph{Markov-Lokalisierung}
					\begin{itemize}
						\item Die Position wird als Aufenthaltswahrscheinlichkeit auf einem bekannten Umweltmodell modelliert, basierend auf den aktuellen Sensordaten.
					\end{itemize}
				\item \emph{Monte-Carlo-Lokalisierung}
					\begin{itemize}
						\item Die Position wird als Dichte von Partikeln betrachtet.
						\item Es werden Beobachtungs- und Bewegungsmodelle verwendet:, 
							\begin{itemize}
								\item Das Beobachtungsmodell modelliert die Wahrscheinlichkeit der Aufnahme von Sensordaten an bestimmten Positionen.
								\item Das Bewegungsmodell modelliert die Wahrscheinlichkeit von Bewegungen, die zu einer bestimmten, relativen RAN führen.
							\end{itemize}
					\end{itemize}
			\end{enumerate}
		
			\subsection{Nichtlineare Ausgleichsrechnung}
				\label{sec:least_squares}
			
				Bei der \emph{nichtlinearen Ausgleichsregelung} (auch als \emph{Methode der kleinsten Quadrate}, \emph{ninlinear least squares} bezeichnet) ist ein nichtlineares Minimierungsproblem
				\begin{equation*}
					\min_{\vec{p} \in \R^{n_p}} \> \varphi_2(\vec{p}),\quad \varphi_2 : \R^{n_p} \to \R
				\end{equation*}
				mit dem zu minimierenden Gütekriterium (Kostenfunktion)
				\begin{equation*}
					\varphi_2(\vec{p}) \coloneqq \frac{1}{2} \sum_{i = 1}^{n_r} \omega_i \big(r_i(\vec{p})\big)^2
				\end{equation*}
				mit den reellen Gewichten \( \omega_i \in \R^+ \) und einer Fehlerfunktion \( r_i : \R^{n_p} \to \R \).
				
				\paragraph{Beispiel}
					In diesem Beispiel sind mehrere Randpunkte \( (x_i, y_i) \), \( i = 1, \cdots, n_r \) eines Balls gegeben und es soll der Mittelpunkt \( (x_K, y_K) \) sowie der Radius \( R_K \) des Balls gefunden werden, \dh Parameter \( \vec{p} = \begin{bmatrix} x_K & y_K & R_K \end{bmatrix} \in \R^3 \) (\( n_p = 3 \)), für die für alle \( (x_i, y_i) \) gilt:
					\begin{equation*}
						(x_i - x_K)^2 + (y_i - y_K)^2 = R_K^2 \tag{Kreisgleichung}
					\end{equation*}
					Da die Messwerte unsicherheitsbehaftet sind, ist eine exakte Bestimmung der Parameter nicht möglich, weshalb eine nichtlineare Ausgleichsregelung mit der Fehlerfunktion
					\begin{equation}
						r_i(x_K, y_K, R_K) = \sqrt{(x_i - x_K)^2 + (y_i - y_K)^2} - R_K \label{eqn:least_squares_example_good}
					\end{equation}
					verwendet wird.
					
					Im Gegensatz zu einer alternativen Fehlerfunktion
					\begin{equation}
						r_i(x_K, y_K, R_K) = \sqrt{(x_i - x_K)^2 + (y_i - y_K)^2 - R_K^2} \label{eqn:least_squares_example_bad}
					\end{equation}
					ist Funktion~\ref{eqn:least_squares_example_good} numerisch besser, da die Ableitung von~\ref{eqn:least_squares_example_bad} im Grenzfall nicht differenzierbar ist.
				% end
			% end
		% end

		\section{Selbstlokalisierung und Navigation}
			Das Ziel der \emph{Selbstlokalisierung} ist die Bestimmung des Aufenthaltsortes eines Roboters relativ zu einer Ausgangsposition oder absolut bezogen auf ein Weltkoordinatensystem. Für den Rest des Kapitels wird dabei angenommen, dass eine absolute Positionsbestimmung mit GPS oder ähnlichem nicht verfügbar ist (\zB innerhalb von Gebäuden oder Tunneln). In der Praxis ist eine Kombination der im folgenden untersuchten Methoden mit GPS natürlich möglich uns sinnvoll.
			
			Das allgemeine Vorgehen besteht aus zwei Schritten:
			\begin{enumerate}
				\item Messen der (Eigen-)~Bewegung des Roboters (Änderung des Aufenthaltsortes) sowie der Umgebung (mit externen Sensoren), was Hinweise auf die absolute Position liefert.
				\item Verarbeitung der Messdaten zu einer (deterministischen oder probabilistischen) Vermutung (Hypothese) über den Aufenthaltsort.
			\end{enumerate}
			Dazu werden geeignete interne und externe Sensoren, Modelle der Sensoren und der Bewegung, geeignete Darstellung der Vermutung(en) über den Aufenthaltsort sowie geeignete Verfahren zur Sensordatenfusion benötigt.
			
			Die unterschiedlichen Verfahren können nach einigen Eigenschaften klassifiziert werden:
			\begin{enumerate}
				\item Verwendung einer Karte (bekannt oder nicht bekannt, metrisch oder topologisch)
				\item Art und Anzahl der Hypothesen über den Aufenthaltsort/die RAN des Roboters.
				\item Jeweilige Problemstellung (relative/absolute Bestimmung/Verfolgung der RAN).
				\item Deterministisch oder nicht deterministisch (probabilistisch).
				\item Verwendete/benötigte Sensoren.
			\end{enumerate}
		
			\subsection{Metrische und Topologische Beschreibung des Aufenthaltsortes}
				\paragraph{Metrische Beschreibung}
					Bei der metrischen Beschreibung wird die RAN Allgemein durch einen Vektor \( \vec{x} \in \R^n \) beschrieben, wobei \(n\) die Dimension der RAN ist. Bei einem Fahrzeug in der Ebene ist diese \( n = 3 \) (Position und Winkel), bei einem Körper im Raum ist diese \( n = 6 \) (Position und Orientierung). Prinzipiell sind aber auch höhere Dimensionen denkbar, wenn der Roboterzustand genauer modelliert wird.
				% end
				
				\paragraph{Topologische Beschreibung}
					Bei der topologischen Beschreibung wird das Umgebungsmodell als Graph modelliert und der mobile Roboter befindet sich in einem der Knoten.
				% end
			% end
			
			\subsection{Messungenauigkeiten/-unsicherheiten}
				Bei sowohl der metrischen als auch der topologischen Beschreibung tritt das Problem auf, dass keine genauen Daten der Roboterbewegung verfügbar sind:
				\begin{itemize}
					\item Ungenauigkeiten der Sensoren
					\item Spiel und Elastizitäten (\zB in den Antrieben)
					\item nicht im Kinematikmodell erfasstes, reales Roboterverhalten (\zB Rutschen, Kippen, Wackeln)
				\end{itemize}
				Eine Lösungsmöglichkeit ist die Modellierung der RAN/des aktuellen Knotens durch eine Wahrscheinlichkeitsverteilung über den verwendeten Raum/den verwendeten Graphen. Dabei bestimmt die Art der Modellierung der Wahrscheinlichkeitsverteilung wesentlich das verwendete Verfahren zur Selbstlokalisierung, \bzw Sensordatenfusion.
			% end

			\subsection{Lokalisierung mit einer Hypothese}
				Bei der Lokalisierung mit einer Hypothese wird zu jedem Zeitpunkt mit genau einer Schätzung der RAN gearbeitet.

				\subsubsection{Koppelnavigation}
					Bei der \emph{Koppelnavigation} wird die Roboterbewegung anhand interner Sensoren gemessen und durch Auswertung der Bewegungsgleichungen die Änderung von Position und Orientierung nach jeder erfassten Bewegung berechnet. Dabei erfolgt keine Messung der Umgebung, \dh es findet nur eine relative Bestimmung der RAN statt und Messfehler können weder erkannt noch korrigiert werden.
					
					Dies ist problematisch, da der Fehler der RAN-Schätzung so beliebig ansteigen kann. Daher ist eine Koppelnavigation nur für kurzzeitige Schätzungen geeignet.
				% end

				\subsubsection{(Erweitertes) Kalman-Filter}
					Das \emph{erweiterte Kalman-Filter} (EKF) erlaubt die Fusion der Messdaten von mehreren Sensoren (auch mit verschiedenen Messraten). Dabei wird die RAN-Schätzung als normalverteilte Zufallsvariable modelliert. Das Ergebnis ist eine statistisch optimale Schätzung des Systemzustands\footnote{Das Kalman-Filter ist ein Bayes'scher Minimum-Varianz-Schätzer für lineare stochastische Systeme in Zustandsraumdarstellung}.
					
					Sowohl das Robotersystem als auch die Messungen werden durch Modelle beschrieben. Das Mess- und Systemrauschen wird sowie Schätzung des Systemzustands werden dabei als ein Vektor normalverteilter Zufallsvariablen modelliert.
					
					Ausgehend von einer Startschätzung wird dann die RAN des Roboters verfolgt. Während der Laufzeit werden zwei Verarbeitungsschritte immer wieder ausgeführt:
					\begin{itemize}
						\item \emph{Time-Update} (Vorhersage) \\ Auf Basis des momentanen Zustands wird, unter Verwendung von Systemfunktionen (Bewegungsmodell), der Folgezustand geschätzt (a-priori Schätzung).
						\item \emph{Measurement-Update} (Korrektur) \\ Die a-priori Schätzung wird mit Hilfe der neusten Messungen externer Sensoren korrigiert.
					\end{itemize}
				
					\paragraph{Diskretisierung der Bewegungsdynamik}
						Das allgemeine Roboterbewegungsmodell ist eine nichtlineare und zeitkontinuierliche Differentialgleichung
						\begin{equation*}
							\dot{\vec{x}}(t) = \vec{F}\big(\vec{x}(t), \vec{u}(t)\big)
						\end{equation*}
						mit dem Systemzustand \( \vec{x} \in \R^n \) und der Systemsteuerung \( \vec{u} \in \R^l \).
						
						Mit \( \vec{x}_k \coloneqq \vec{x}(t_k) \), \( \vec{u}_k \coloneqq \vec{u}(t_k) \), einer "Schrittweite" \( h_k \coloneqq t_{k + 1} - t_k \) und der Approximation
						\begin{equation*}
							\dot{\vec{x}}(t_{k + 1}) \approx \frac{1}{h_k} (\vec{x}_{k + 1} - \vec{x}_k) = \vec{F}(\vec{x}_k, \vec{u}_k)
						\end{equation*}
						kann daraus ein zeitdiskretes, dynamisches Modell ermittelt werden:
						\begin{align*}
							\vec{x}_{k + 1} =                       & \,\, \vec{f}(\vec{x}_k, \vec{u}_k)                 \\
							\vec{f}(\vec{x}_k, \vec{u}_k) \coloneqq & \,\, \vec{x}_k + h_k \vec{F}(\vec{x}_k, \vec{u}_k)
						\end{align*}
						Im folgenden wird immer ein zeitdiskrete Modell vorausgesetzt. In der Praxis orientieren sich die Zeitschritte \( t_k \), \bzw \( h_k \), an den Taktraten der (schnellsten) Sensordaten.
					% end
					
					\paragraph{Probabilistisches Systemmodell}
						Mit dem Systemrauschen \( \vec{w} \in \R^n \), ein Vektor von mittelwertfreien, normalverteilten Zufallsvariablen mit Kovarianzmatrix \( \mat{Q} \in \R^{n \times n} \), wird das Systemmodell wie folgt erweitert:
						\begin{equation*}
							\vec{x}_k = \vec{f}(\vec{x}_{k - 1}, \vec{u}_{k - 1}) + \vec{w}_{k - 1}
						\end{equation*}
						Durch dieses Rauschen kann der Systemzustand nicht mehr deterministisch angegeben werden, da er von der Zufallsvariablen \( \vec{w} \) abhängt.
						
						Jedoch kann der Systemzustand nun als ein Vektor normalverteilter, unabhängiger Zufallsvariablen mit
						\begin{itemize}
							\item Mittelwert \( \hat{\vec{x}} \in \R^n \) und
							\item Kovarianzmatrix \( \mat{P} \in \R^{n \times n} \)
						\end{itemize}
						geschätzt/betrachtet werden.
					% end
					
					\paragraph{Probabilistisches Messmodell}
						Mit dem Messrauschen \( \vec{v} \in \R^m \), ein Vektor von mittelwertfreien, normalverteilten Zufallsvariablen mit Kovarianzmatrix \( \mat{R} \in \R^{m \times m} \), lautet das Messmodell wie folgt:
						\begin{equation*}
							\vec{z}_k = \vec{h}(\vec{x}_k) + \vec{v}_k
						\end{equation*}
						Dabei ist \( \vec{x} \in \R^n \) der Systemzustand, \( \vec{z} \in \R^m \) der Messwert und \( \vec{h} : \R^n \to \R^m \) das Modell der Messung.
					% end

					\paragraph{Time-Update}
						Beim Time-Update wird, basierend auf
						\begin{itemize}
							\item der Schätzung des Systemzustands \( \hat{\vec{x}}_{k - 1} \) und der Kovarianzmatrix \( \mat{P}_{k - 1} \) zum Zeitpunkt \( k - 1 \) sowie
							\item der Steuereingabe \( \hat{\vec{u}}_{k - 1} \) zum Zeitpunkt \( k - 1 \),
						\end{itemize}
						eine a-priori Schätzung \( \hat{\vec{x}}_k^- \), \( \mat{P}_k^{\,-} \) des Systemzustands zum Zeitpunkt \(k\) berechnet, \dh die Parameter des Priors \( p(\vec{x}_k) = \mathcal{N}\,\big(\hat{\vec{x}}_k^-, \mat{P}_k^{\,-}\big) \).
						
						Mit der gegebenen Kovarianzmatrix \( \mat{Q} \) des Systemrauschens sowie der Jacobi-Matrix
						\begin{equation*}
							\mat{A}_k \coloneqq \frac{\partial \vec{f}(\hat{\vec{x}}_k^-, \vec{u}_k)}{\partial \vec{x}}
						\end{equation*}
						der Systemfunktion ausgewertet an der a-priori Schätzung werden \( \hat{\vec{x}}_k^- \) und \( \mat{P}_k^{\,-} \) wie folgt berechnet:
						\begin{align*}
							\hat{\vec{x}}_k^- & = \vec{f}(\hat{\vec{x}}_{k - 1}, \vec{u}_{k - 1}) \\
							\mat{P}_k^{\,-}       & = \mat{A}_k \mat{P}_{k - 1} \mat{A}_k^T + \mat{Q}
						\end{align*}
						Dabei wird die Schätzung ungenauer, wenn die Werte auf der Hauptdiagonalen vom \( \mat{P} \) ansteigen (\dh wenn die Varianz steigt).
					% end

					\paragraph{Measurement-Update} % 9.34, 9.35, 9.36
						Beim Measurement-Update wird, basierend auf
						\begin{itemize}
							\item der a-priori Schätzung \( \hat{\vec{x}}_k^- \), \( \mat{P}_k^{\,-} \) des Systemzustands und der Kovarianzmatrix zum Zeitpunkt \(k\) und
							\item den Messungen \( \vec{z}_k \) der externen Sensoren zum Zeitpunkt \(k\),
						\end{itemize}
						eine a-posteriori Schätzung \( \hat{\vec{x}}_k \), \( \mat{P}_k \) des Systemzustands und der Kovarianzmatrix zum Zeitpunkt \(k\) berechnet, \dh die Parameter des Posteriors \( p(\vec{x}_k \given \vec{z}_k, \cdots, \vec{z}_1) = \mathcal{N}\,\big(\hat{\vec{x}}_k, \mat{P}_k\big) \).
						
						Mit der gegebenen Kovarianzmatrix \( \mat{R} \) des Messrauschens sowie der Jacobi-Matrix
						\begin{equation*}
							\mat{H}_k \coloneqq \frac{\partial \vec{h}(\hat{\vec{x}}_k^-)}{\partial \vec{x}}
						\end{equation*}
						der Messfunktion ausgewertet an der a-priori Schätzung werden \( \mat{K}_k \) (die \emph{Kalmanverstärkung}), \( \hat{\vec{x}}_k \) und \( \mat{P}_k \) wie folgt berechnet:
						\begin{align*}
							\mat{K}_k &= \mat{P}_k^{\,-} \mat{H}_k^T \big( \mat{H}_k \mat{P}_k^{\,-} \mat{H}_k^T + \mat{R} \big)^{-1} \\
							\hat{\vec{x}}_k &= \hat{\vec{x}}_k^- + \mat{K}_k \big( \vec{z}_k - \vec{h}(\hat{\vec{x}}_k^-) \big) \\
							\mat{P}_k &= (\mat{E} - \mat{K}_k \mat{H}_k) \mat{P}_k^{\,-}
						\end{align*}
						Wobei \( \mat{E} \) die Einheitsmatrix darstellt.
						
						Die grundlegende Idee des Filter ist, zunächst die Kalmanverstärkung \( \mat{K} \) so zu berechnen, dass die Varianz der a-posteriori Schätzung minimal wird. Anschließend wird der Mittelwert der der (durch \( \mat{K} \) gewichteten) Abweichung der erwarteten Messung von der tatsächlichen Messung korrigiert.
						
						\begin{itemize}
							\item In der Regel weicht die tatsächliche Messung \( \vec{z} \) von dem erwarteten Messwert \( \vec{h} \) ab (um das Residuum \( \vec{r}_k \coloneqq \vec{z}_k - \vec{h}(\hat{\vec{x}}_k^-) \)).
							\item Die Fehlerkovarianzmatrix \( \mat{P} \) beschreibt insgesamt die Zuverlässigkeit der Zustandsschätzung.
							\item Der Mahalanobis-Abstand \( d_k \coloneqq \vec{r}_k^T \mat{P}_k^{\,-1} \vec{r}_k \) kann als Maß für die Vertrauenswürdigkeit der Messungen genutzt werden. Dadurch können potentielle Ausreißer und falsche Messwerte anhand besonders großer \( d_k >> 0 \) erkannt werden.
							\item Durch die Elimination von Ausreißern ist das Verfahren somit stabil gegenüber einzelnen Falschmessungen in Komponenten von \( \vec{z}_k \).
						\end{itemize}
					% end
					
					\paragraph{Vor- und Nachteile des EKF}
						\begin{itemize}
							\item \textbf{Vorteile:}
								\begin{itemize}
									\item Das EKF ist ein etabliertes Verfahren, vielfach implementiert und es ist viel Know-How vorhanden.
									\item Es ermöglicht eine Plausibilitätsprüfung der Messwerte, \dh Ausreißer können erkannt und verworfen werden.
								\end{itemize}
							\item \textbf{Nachteile:}
								\begin{itemize}
									\item Mehrdeutigkeiten können nicht dargestellt werden (\dh es kann immer nur genau eine Hypothese verfolgt werden).
									\item Die Bestimmung der Anfangsposition erfordert eine absolute Positionsbestimmung, \zB über Landkarten.
									\item Die Normalverteilungen erlauben keine Abbildung von Hindernissen im Modell (\zB können keine Nebenbedingungen der Form \( g(\vec{x}) \geq 0 \) zur Kollisionsvermeidung berücksichtigt werden).
									\item Das zeitkontinuierliche Modell wird linearisiert, \dh die Unsicherheiten müssen, relativ zu den Taktraten \( h_k \), klein sein.
								\end{itemize}
						\end{itemize}
					% end
				% end
			% end

			\subsection{Lokalisierung mit mehreren Hypothesen}
				\begin{itemize}
					\item Verfahren mit nur einer Hypothese haben vielfältige Nachteile:
						\begin{itemize}
							\item Mehrdeutigkeiten können nicht modelliert werden.
							\item Es ist eine eindeutige Zuordnung der Merkmale erforderlich.
							\item Es ist eine Schätzung des Anfangszustandes nötig.
							\item Es werden globale Merkmale benötigt, um den Zustand eines verirrten Roboters wiederzufinden.
						\end{itemize}
					\item Eine Abhilfe dieser Probleme ist die gleichzeitige Verfolgung mehrerer Hypothesen über den Systemzustand.
				\end{itemize}

				\subsubsection{Verwendung mehrerer Kalman-Filter ("Multiple Hypothesis Tracking")}
					\begin{itemize}
						\item Bei der Verwendung mehrerer Kalman-Filter wird für jede Hypothese ein Kalman-Filter genutzt und die Time- und Measurement-Updates parallel auf allen Hypothesen durchgeführt.
						\item Die Plausibilität der einzelnen Hypothesen wird auf Basis der vorliegenden Messwerte bewertet.
						\item Sind Messwerte uneindeutig, so wird eine Hypothese in mehrere aufgespaltet.
						\item Problem: Die Anzahl der Hypothesen kann exponentiell anwachsen.
						\item Das Ziel ist somit das klein halten der Anzahl an Hypothesen. Dazu sind verschiedene Operationen nötig:
							\begin{itemize}
								\item Bewerten von Hypothesen
								\item Erzeugen neuer Hypothesen
								\item Verwerfen von Hypothesen
								\item Vereinigen von Hypothesen
							\end{itemize}
					\end{itemize}
				
					Zunächst muss die Hypothesenmenge jedoch modelliert werden. Die \(i\)-te Hypothese (\( i \in \{\, 1, \cdots, N \,\} \)) zum Zeitpunkt \(k\) wird dabei dargestellt durch ein Tripel
					\begin{equation*}
						H_k^{(i)} \coloneqq \Big( \vec{x}_k^{(i)}, \mat{P}_k^{\,(i)}, p_k^{(i)} \Big)
					\end{equation*}
					mit dem Erwartungswert \( \vec{x}_k^{(i)} \), der Kovarianzmatrix \( \mat{P}_k^{\,(i)} \) und einer Gewichtung \( p_k^{(i)} \geq 0 \) (die Wahrscheinlichkeit, dass eine Hypothese gilt). Jede Hypothese wird dabei durch eine Normalverteilung \( p_k^{(i)} = \mathcal{N}\,\Big( \vec{x}_k^{(i)}, \mat{P}_k^{\,(i)} \Big) \) dargestellt.
					
					Außerdem muss dafür gesorgt werden, dass die Wahrscheinlichkeiten \( p_k^{(i)} \) normiert sind, \dh es muss
					\begin{equation*}
						p_k^{(0)} + \sum_{i = 1}^{N} p_k^{(i)} = 1
					\end{equation*}
					gelten, wobei \( p_k^{(i)} \) die Wahrscheinlichkeit ist, dass keine Hypothese gilt.
					
					\paragraph{Vorgehen}
						\begin{enumerate}
							\item \emph{Time-Update} \\ Für jede Hypothese wird ein normales Time-Update durchgeführt.
							\item \emph{Measurement-Update} \\ Die Umgebungsdaten werden gemessen und ein Measurement-Update auf die Hypothesen angewandt, zu denen die Umgebungsdaten passen.
							\item \emph{Neubewerten} der Wahrscheinlichkeiten der Hypothesen
								\begin{itemize}
									\item Die Wahrscheinlichkeit, dass der aktuelle Messwert \( \vec{z} \) bei Gültigkeit der Hypothese \( i \) gemessen wird, sei \( P\Big(\vec{z} \,\big\vert\, H_k^{(i)}\Big) \).
									\item Mit dem Normierungsfaktor \(c\) werden nun alle Hypothesen neu bewertet:
								\end{itemize}
						\end{enumerate}
						\begin{equation*}
							p_k^{(i_\text{neu})} = c p_k^{(i)} P\Big(\vec{z} \,\big\vert\, H_k^{(i)}\Big)
						\end{equation*}
						
						Eine Messung der Umgebung kann neue Hypothesen (sogenannte Kandidaten) über den Systemzustand produzieren. Diese Kandidaten werden unterteilt in
						\begin{itemize}
							\item solche, die in der Nähe einer bestehenden Hypothese liegen und dieser unterstützen \( \to \) Anwenden eines Measurement-Updates auf diese Hypothese.
							\item solche, die keine bestehende Hypothese unterstützen \( \to \) Hinzufügen einer neuen Hypothese zur Hypothesenmenge.
						\end{itemize}
						Dabei muss beachtet werden, dass die Menge an Hypothesen nicht beliebig anwächst, \dh es müssen auch Hypothesen verworfen werden, \zB wenn
						\begin{itemize}
							\item die Wahrscheinlichkeit \( p_k^{(i)} \) unter einer bestimmten Schwelle liegt: \( p_k^{(i)} < p_\text{min} \),
							\item die Hypothese "weit genug" außerhalb der Karte liegt (unter der Annahme, dass die Karte vollständig ist) oder
							\item die Hypothese innerhalb von Hindernissen liegt.
						\end{itemize}
						Wurde eine Hypothese entfernt, so müssen die Wahrscheinlichkeiten danach neu normiert werden! Neben dem entfernen von Hypothesen können diese auch Zusammengefasst werden. Dies wird durchgeführt, wenn die Hypothesen dich beieinander liegen, \dh \( \big\lVert \vec{x}_k^{(i)} - \vec{x}_k^{(j)} \) klein ist. Die Wahrscheinlichkeit der neuen Hypothese entspricht dann der Summer der Ausgangshypothesen.
					% end
					
					\paragraph{Vor- und Nachteile von Multiple Hypothesis Tracking}
						\begin{itemize}
							\item \textbf{Vorteile:}
								\begin{itemize}
									\item Es sind mehrere, konkurrierende Hypothesen möglich.
									\item Der Rechenaufwand skaliert mit der Anzahl der Hypothesen.
									\item Es ist eine aktive Lokalisierung möglich.
										\begin{itemize}
											\item Aktive Lokalisierungsverfahren steuern den Roboter so, dass der Lokalisierungsfehler/die Kosten für die Bewegung eines schlecht lokalisierten Roboters in einen gefährlichen Bereich, minimiert werden.
											\item Passive Lokalisierungsverfahren beobachten nur den Roboter, der auf andere Weise gesteuert wird, aber nicht so, dass eine Lokalisierung vereinfacht wird.
										\end{itemize}
								\end{itemize}
							\item \textbf{Nachteile:}
								\begin{itemize}
									\item Die geometrischen Umgebungsdaten können nicht direkt mit in die Hypothesen einbezogen werden.
									\item Es wird angenommen, dass Störungen normalverteilt und statistisch unabhängig sind.
									\item Das zeitkontinuierliche Modell wird linearisiert, \dh die Unsicherheiten müssen, relativ zu den Taktraten \( h_k \), klein sein.
								\end{itemize}
						\end{itemize}
					% end
				% end

				\subsubsection{Diskretisierte Wahrscheinlichkeitsverteilung}
					Die RAN eines Roboters wird durch einen \(n\)-dimensionalen Vektor beschrieben, wobei die genaue RAN nicht angegeben werden kann, sondern nur eine Wahrscheinlichkeitsverteilung über den metrischen Raum. Diese Verteilung kann sehr ungleichmäßig sein, speziell bei der Berücksichtigung von Hindernissen.
					
					\textbf{Ansatz:} Der metrische Raum wird diskretisiert (\zB durch eine Zellzerlegung im Konfigurationsraum) und es wird die Wahrscheinlichkeit
					\begin{equation*}
						P(\vec{x}),\quad \vec{x} \in \{\, \vec{x}_1, \cdots, \vec{x}_N \,\},\quad P(\vec{x}) \in [0, 1]
					\end{equation*}
					für jede RAN in einem Feld (Position Probability Grid) gespeichert (zu Anfang einer Gleichverteilung folgend). Bewegt der Roboter sich oder treffen neue Sensordaten ein, so erfolgt eine Neuberechnung der Wahrscheinlichkeiten.
					
					\paragraph{Motion-Update}
						Eine Bewegung sei gegeben als Änderung \( \vec{\Delta} \) des Systemzustands \(\vec{x}\):
						\begin{equation*}
							\vec{x}_k = \vec{x}_{k - 1} + \vec{\Delta}
						\end{equation*}
						Des weiteren wird durch eine Weltmodell \(m\) eine Wahrscheinlichkeit \( P(\vec{x} \given m) \) vorgegeben, dass \(\vec{x}\) eingenommen werden kann.
						
						Bei einem solchen \emph{Motion-Update} wird die Wahrscheinlichkeitsverteilung wie folgt neu berechnet:
						\begin{equation*}
							P_\text{neu}(\vec{x}) =
								\begin{cases*}
									P(\vec{x} - \vec{\Delta}) \cdot P(\vec{x} \given m) & falls \( (\vec{x} - \vec{\Delta}) \) möglicher Ausgangsort \\
									0 & sonst
								\end{cases*}
						\end{equation*}
						Nach den Berechnungen muss \(p\) normiert werden. Durch dieses Aktualisieren der Wahrscheinlichkeitsverteilung werden Fehler in der Messung durch ein Glätten von \( p \) modelliert.
					% end
					
					\paragraph{Measurement-Update}
						Das Sensormodell und das Weltmodell \(m\) geben die Wahrscheinlichkeit
						\begin{equation*}
							P(\vec{x} \given \vec{x}, m)
						\end{equation*}
						an, dass \( \vec{z} \) bei der RAN \( \vec{x} \) gemessen wird.
						
						Dadurch wird die Berechnung der aktualisierten Wahrscheinlichkeit nach einer Messung \( \vec{z} \) (\emph{Measurement-Update}) möglich:
						\begin{equation*}
							P_\text{neu}(\vec{x}) = P(\vec{z} \given \vec{x}, m) \cdot P(\vec{x})
						\end{equation*}
						Somit werden aus der anfänglichen Gleichverteilung nach und nach die unwahrscheinlichen Hypothesen eliminiert.
					% end
					
					\paragraph{Vor- und Nachteile des Position Probability Grids}
						\begin{itemize}
							\item \textbf{Vorteile:}
								\begin{itemize}
									\item Die Modellierung beliebig vieler Hypothesen verändert die Laufzeit nicht.
									\item Es kann Wissen über die Umgebungsgeometrie einbezogen werden.
									\item Es ist eine aktive Lokalisierung möglich.
								\end{itemize}
							\item \textbf{Nachteile:}
								\begin{itemize}
									\item Sehr rechenaufwändig.
									\item Die Auflösung des Zustandsraums ist begrenzt.
								\end{itemize}
						\end{itemize}
					% end
				% end

				\subsubsection{Monte-Carlo Lokalisierung}
					Bei der \emph{Monte-Carlo Lokalisierung} wird die Wahrscheinlichkeitsverteilung approximiert:
					\begin{itemize}
						\item Die Darstellung erfolgt durch eine Menge von Partikeln (samples).
						\item Dabei beschreibt jeder Partikel eine mögliche RAN des Roboters.
						\item Ein solcher Partikel kann eine RAN präzise wiedergeben (es ist keine Diskretisierung notwendig).
					\end{itemize}
					Bei einer Bewegung des Roboters wird die Lage der Partikel verändert, bei einer Sensormessung die Wahrscheinlichkeit der Partikel. Vorausgesetzt werden stochastische Modelle der Bewegung und der Sensorik.
					
					Die Wahrscheinlichkeitsverteilung wird durch \(N\) Partikel dargestellt, die jeweils durch ein Tupel aus Systemzustand \( \vec{x}_i \) und Wahrscheinlichkeit \( p_i \in [0, 1] \) beschrieben werden:
					\begin{equation*}
						S_i \coloneqq (\vec{x}_i, p_i)
					\end{equation*}
					Die Wahrscheinlichkeit über alle Partikel muss dabei normiert sein, \dh \( \sum_{i = 1}^{N} p_i = 1 \).
					
					\paragraph{Probabilistisches Bewegungsmodell}
						Das probabilistische Bewegungsmodell
						\begin{equation*}
							P(\vec{x} \given \vec{x}', \vec{u})
						\end{equation*}
						beschreibt die Wahrscheinlichkeit eines Zustands \( \vec{x} \) nach der Ausführung einer Bewegung \( \vec{u} \) im Zustand \( \vec{x}' \).
					% end
					
					\paragraph{Bewegungen}
						Bewegt sich der Roboter, so wird eine neue Wahrscheinlichkeitsverteilung erzeugt:
						\begin{enumerate}
							\item Erzeugen einer neuen Verteilung
								\begin{itemize}
									\item \(N\)-maliges "Ziehen" aus der alten Verteilung unter Berücksichtigung der Wahrscheinlichkeiten.
									\item Dadurch werden Partikel mit hoher Wahrscheinlichkeit vervielfacht und Partikel mit niedriger Wahrscheinlichkeit ausgedünnt.
									\item Danach wird die Wahrscheinlichkeit aller neuen Partikel auf \( 1/N \) gesetzt.
								\end{itemize}
							\item Bewegen der Partikel
								\begin{itemize}
									\item Vorausgesetzt wird, dass die ausgeführte Bewegung \( \vec{u} \) bekannt ist.
									\item Der in den Partikeln gespeicherte Systemzustand wird, entsprechend der Wahrscheinlichkeitsverteilung \( P(\vec{x} \given \vec{x}', \vec{u}) \), zufällig geändert.
								\end{itemize}
						\end{enumerate}
					% end
					
					\paragraph{Messungen}
						Der externe Sensorwert \( \vec{z} \) hängt von dem Systemzustand des Roboters ab, wobei das Verhalten der Messung als Wahrscheinlichkeitsverteilung
						\begin{equation*}
							\P(\vec{z} \given \vec{x})
						\end{equation*}
						beschrieben wird. Für jeden Systemzustand ist damit die Wahrscheinlichkeit jeder möglichen Messung gegeben.
						
						Das Ziel ist nun, die Wahrscheinlichkeiten der Partikel durch gemessene Sensordaten neu zu bewerten. Dazu werden alle Partikel neu gewichtet:
						\begin{equation*}
							p_{i_\text{neu}} = p_i P(\vec{z} \given \vec{x}_i)
						\end{equation*}
						Anschließend müssen die Wahrscheinlichkeiten wieder normiert werden.
					% end
					
					\paragraph{Vor- und Nachteile der Monte-Carlo Lokalisierung}
						\begin{itemize}
							\item \textbf{Vorteile:}
								\begin{itemize}
									\item Es ist fast jede Wahrscheinlichkeitsverteilung annäherbar.
									\item Einfach zu implementieren.
									\item Die Anzahl der Partikel kann zur Laufzeit angepasst werden (Genauigkeit \(\leftrightarrow\) Rechenleistung).
									\item Es kann Wissen über die Umgebungsgeometrie einbezogen werden.
									\item Es ist eine aktive Lokalisierung möglich.
									\item Effizienter als Position Probability Grid.
								\end{itemize}
							\item \textbf{Nachteile:}
								\begin{itemize}
									\item Für die Robustheit des Verfahrens wird eine Mindestanzahl an Partikeln benötigt.
								\end{itemize}
						\end{itemize}
					% end
				% end
			% end

			\subsection{Simultaneous Localization and Mapping (SLAM)}
				\label{sec:slam}
			
				Bisher wurde immer davon ausgegangen, dass ein Umweltmodell gegeben ist. Wird ein Roboter jedoch in einer unbekannten Umgebung eingesetzt, so müssen Selbstlokalisierung auf Aufbau der Karte simultan gelöst werden. Verfügbar sind dabei:
				\begin{itemize}
					\item Odometrie sowie Steuerungsdaten
					\item Daten externer Sensoren
				\end{itemize}
				Zu ermitteln sind:
				\begin{itemize}
					\item Karte der Umgebung
					\item Trajektorie des Roboters
				\end{itemize}
			
				SLAM ist dabei ein klassisches Henne-Ei-Problem:
				\begin{itemize}
					\item Für die Lokalisierung ist eine Karte erforderlich,
					\item für die Kartierung ist Lokalisierung erforderlich.
				\end{itemize}
				Beide Probleme allein sind dabei vergleichsweise einfach lösbar, die Kombination ist jedoch kompliziert:
				\begin{itemize}
					\item Im Allgemeinen sind nur Sensordaten relativ zum Roboter verfügbar und keine absoluten Daten.
					\item Ein Fehler in der RAN-Schätzung erzeugt Fehler bei der Kartenerstellung.
					\item Fehler können erst beim Schließen von Schleifen ("Loop Closing") erkannt und korrigiert werden.
					\item Die Assoziation von Daten kann schwer sein (die Zuordnung von Sensordaten).
				\end{itemize}
			
				Dabei gibt es zwei grundlegende Kartentypen:
				\begin{itemize}
					\item \emph{Merkmals-basierte Karten}
						\begin{itemize}
							\item Es werden Merkmale aus den Sensordaten extrahiert und eine Menge von Merkmalen bildet die Karte.
							\item Die Karte kann nur so gut sein wie die gelieferten Merkmale.
						\end{itemize}
					\item \emph{Gitter-basierte Karten}
						\begin{itemize}
							\item Der Zustandsraum wird Diskretisiert und in Gitter aufgeteilt.
							\item Pro Gitterzelle wird eine Schätzung der Belegungswahrscheinlichkeit durchgeführt.
							\item Eine "dichte" Karte ist Vorteilhaft bei der Bahnplanung.
							\item Sehr hoher Rechenbedarf für eine hohe Anzahl an Freiheitsgraden, daher fast nur für 2D-Karten eingesetzt.
						\end{itemize}
				\end{itemize}

				\subsubsection{EKF SLAM}
					Es wird ein erweitertes Kalman-Filter eingesetzt:
					\begin{itemize}
						\item Erster erfolgreicher SLAM-Algorithmus.
						\item Der geschätzte Zustand ist nicht nur die RAN des Roboters, sondern auch die Position der Landmarken.
						\item Der Zustandsvektor vergrößert sich mit der Anzahl der Landmarken.
						\item Die Anzahl der Elemente der beim Update zu invertierenden Matrix wächst quadratisch.
						\item Eine einzige Kantenhypothesen.
						\item Datenassoziation problematisch.
					\end{itemize}
				
					\begin{itemize}
						\item \textbf{Vorteile:}
							\begin{itemize}
								\item Eignet sich auch gut für die Schätzung einer 6-DoF-RAN.
								\item Die Korrelation zwischen Landmarken wird mit geschätzt.
							\end{itemize}
						\item \textbf{Nachteile:}
							\begin{itemize}
								\item Nicht robust bei fehlerhafter Datenassoziation, was zu einer Divergenz des Filters und zum Verlust von Karte und Lokalisierung führen kann.
								\item Aufgrund der in EKF zugrundeliegenden Linearisierung müssen Unsicherheiten klein bleiben.
								\item Der Rechenaufwand steigt quadratisch mit Anzahl der Landmarken.
								\item Ausschließlich merkmalsbasiert und daher stark anfällig von Qualität und Anzahl der Merkmale.
							\end{itemize}
					\end{itemize}
				% end

				\subsubsection{FastSLAM}
					Benutzung eines Rao-Blackwellize Particle Filters:
					\begin{itemize}
						\item Die RAN des Roboters wird mit Partikeln modelliert.
						\item Jeder Partikel besitzt eine eigene Kantenhypothese.
						\item Bei bekannter Robotertrajektorie sind die Merkmale stochastisch unabhängig voneinander.
							\begin{itemize}
								\item Ausnutzung dieser Tatsache, Schätzung mehrerer Robotertrajektorien und dazugehörige Kanten.
								\item Kantenmerkmale können unabhängig voneinander geschätzt werden.
							\end{itemize}
						\item Es ist sowohl eine Merkmals- als auch Gitter-basierte Variante der Kartenrepräsentation möglich.
					\end{itemize}
				
					\begin{itemize}
						\item \textbf{Vorteile:}
							\begin{itemize}
								\item Robust durch Datenassoziation und Kartenschätzung pro Partikel.
								\item Die Laufzeit und die Qualität sind über die Partikelanzahl skalierbar.
							\end{itemize}
						\item \textbf{Nachteile:}
							\begin{itemize}
								\item Je nach Kartenrepräsentation und Anzahl der Partikel hoher Speicher- und Rechenzeitbedarf.
								\item Beim Schließen großer oder verschachtelter Schleifen treten Problem durch Partikelverarmung auf.
								\item Skaliert schlecht mit der Erhöhung der geschätzten Freiheitsgrade der RAN.
							\end{itemize}
					\end{itemize}
				% end

				\subsubsection{Graph-basiertes SLAM}
					SLAM-Problem als RAN-Graph-Optimierungsproblem:
					\begin{itemize}
						\item Aufeinanderfolgende Odometriedaten erzeugen Zwangsbedingungen zwischen mehreren RANs.
						\item Die Beobachtung von Landmarken erzeugen Zwangsbedingungen zwischen RANs und Landmarken.
						\item Optimierung über den gesamten Pfad des Roboters (hier sind eine Vielzahl unterschiedlicher Optimierungsverfahren und Implementierungsvarianten möglich).
						\item Bisher hauptsächlich offline angewandt, mittlerweile aber auch verstärkt im Einsatz unter Echtzeitbedingungen.
					\end{itemize}
				% end

				\subsubsection{Limitierungen}
					SLAM ist bereits für eine Vielzahl von Problemen gelöst, aber es gibt noch keine gleichzeitige Erfüllung aller Kriterien:
					\begin{itemize}
						\item Dreidimensionale Kartierung
						\item Integration semantischer Informationen
						\item Echtzeitfähigkeit
						\item Robustheit
						\item Skalierbarkeit
						\item Einsetzbarkeit in beliebigem Terrain
						\item Nicht-statische Karten
					\end{itemize}
				
					Aktuelle Forschungsrichtungen:
					\begin{itemize}
						\item Semantic Mapping \\ Statt "nur" geometrische Informationen zu kartieren werden zusätzlich semantische Informationen (\zB Place Labeling (Flur, Büro, Schränke)) gespeichert. Dies ist notwendig für zielorientiertes Handeln des Roboters.
						\item Life-long Map Learning \\ Es werden auch Veränderungen in der Umgebung des Roboters berücksichtigt.
						\item Visual SLAM \\ Benutzung von Mono- oder Stereo-Kameras, auch zur 3D-Rekonstruktion der Umgebung.
					\end{itemize}
				% end

				\subsubsection{Visual SLAM}
					Feature-basierte Methoden (Detektion und Matching von eindeutigen Merkmalen):
					\begin{itemize}
						\item \textbf{Vorteile:}
							\begin{itemize}
								\item Effizient (Speicher und Rechenleistung)
								\item Robust gegen Beleuchtungsänderungen, Modellfehler und Initialisierungsfehler
							\end{itemize}
						\item \textbf{Nachteile:}
							\begin{itemize}
								\item Sparse Geometrierekonstruktion
								\item Erfordert Features in der Umgebung
							\end{itemize}
					\end{itemize}
					
					Direkte Methoden (Direktes Matching der Bildinformation):
					\begin{itemize}
						\item \textbf{Vorteile:}
							\begin{itemize}
								\item (Semi-)~Dichte Geometrierekonstruktion
								\item Robuster bei wenigen Features durch Nutzung der gesamten Bildinformation
							\end{itemize}
						\item \textbf{Nachteile:}
							\begin{itemize}
								\item Erfordert gute Initialisierung
								\item Weniger robust gegen Beleuchtungsänderungen und Modellfehler
								\item Rechenintensiv (aber Parallelisierbar auf einer GPU)
							\end{itemize}
					\end{itemize}
				% end

				\subsubsection{Scan-Matching}
					Schnelle Registrierung des aktuellsten Scans mit bisher erstellter Karte.
					\begin{itemize}
						\item Approximation der räumlichen Gradienten der Karte.
						\item Interpolation zwischen den Gitterzellen, dadurch "Subpixel"-Genauigkeit.
						\item Gauss-Newton Verfahren um Maximum-Likelihood Anordnung der Scan-Endpunkte in der Karte zu ermitteln.
						\item Schätzen von Kovarianz der ermittelten Anordnung zur Bewertung der Qualität des Scan-Matchings.
					\end{itemize}
				% end

				\subsubsection{3D SLAM -- Aktuelle Weiterentwicklungen}
					\begin{itemize}
						\item Integration TSDF (Truncated Signed Distance Function) Backend \\ Effiziente Echtzeit-Generierung von Gitternetzmodell.
						\item SLAM unter schwierigen Umgebungsbedingungen (\zB Rauch) mit zusätzlichen Sensoren (\zB Radar, Ultraschall).
						\item Semantisches SLAM
							\begin{itemize}
								\item CNN-basierte Instanzsegmentierung
								\item TSDF Mapping
							\end{itemize}
					\end{itemize}
				% end
			% end
		% end
	% end

	\chapter{Middleware und Simulation}
		\paragraph{Voraussetzungen für intelligente Roboter}
			\begin{itemize}
				\item Forschung
					\begin{itemize}
						\item Seit circa 40 Jahre, sehr stark steigende Anzahl an Konferenzen und Publikationen pro Jahr.
						\item Die Robotics and Automation Society ist die größte und am schnellsten wachsende Fachgesellschaft der IEEE.
					\end{itemize}
				\item Technologie
					\begin{itemize}
						\item Enorm steigende Rechenleistung und Speicherkapazitäten.
						\item Stark steigende Leistungsfähigkeit von Sensortechnologien (\zB LIDAR, Farb-Tiefbild-Kameras wie Kinect und Intel RealSense).
						\item Kontinuierlich steigende Leistungsfähigkeit von Antriebstechnologien, insbesondere von elektrischen Antrieben.
					\end{itemize}
			\end{itemize}
		% end

		\section{Szenarien, Eigenschaften und Herausforderungen}
			Roboter können für die unterschiedlichsten Aufgaben eingesetzt werden. Ständig steigende Komplexität und sich schnell ändernde Hardware erschweren dabei die effiziente Programmierung für solche Einsätze. Wie kann eine "korrekte" und "zuverlässige" Funktionsweise sichergestellt werden?
			
			In Robotern kommen werden viele verschiedene Algorithmen aus verschiedenen Bereichen integriert (Sensordaten Verarbeitung, Objekterkennung, Filterung, Modellierung, Lokalisierung, Kartografierung, Vorhersage, Verhaltensentscheidung, Bewegungssteuerung, \dots). All diese Algorithmen müssen in ein Gesamtsystem integriert und auf dieses und den jeweiligen Roboter angepasst werden. Diese Integration erfordert einen hohen Aufwand.
			
			Gewünschte Software Engineering Kriterien für die Hard-/Software-Komponenten sind dabei:
			\begin{itemize}
				\item Modularität (lose Kopplung zwischen den Komponenten, einfacher Austausch/einfache Änderung der Komponenten)
				\item Wiederverwendbarkeit (auf anderen Robotern, in anderen Szenarien)
				\item Flexibilität (schnelle Anpassung an sich ändernde Hardware, geänderte Aufgabenstellungen)
				\item Korrektheit
				\item Zuverlässigkeit
			\end{itemize}
		% end

		\section{Middleware}
			Roboter-Middleware bildet eine Zwischenschicht zwischen der Hardware und dem Sense -- Plan -- Act Zyklus. Ein weltweit akzeptierter Standard für ein solches System ist ROS, das "Robot Operating System" (wobei es eigentlich kein Betriebssystem ist, sondern eine Middleware, die auf einem Betriebssystem, \zB einem Echtzeit-Linux, eingesetzt wird).
			
			Die Middleware ist dabei der "Kleber" zwischen den Komponenten und sorgt für
			\begin{itemize}
				\item Separation der Komponenten
				\item Standardisierte Mechanismen zur Kommunikation
				\item Interfaces definiert durch die ausgetauschten Daten.
			\end{itemize}
			Dabei gibt es unterschiedliche Ansätze:
			\begin{itemize}
				\item Kommunikations-Orientiert (RPC, Java RMI, Web Service)
				\item Applikation-Orientiert (CORBA, J2EE, .NET)
				\item Nachrichten-Orientiert (JSM, RoboFrame, ROS)
			\end{itemize}

			\subsection{Nachrichtenbasierte Kommunikation}
				\begin{itemize}
					\item Gängige Paradigmen
						\begin{itemize}
							\item Point-to-Point
							\item Fan-Out
							\item Request-Response
							\item Publish/Subscribe
						\end{itemize}
					\item Synchron \vs Asynchron
					\item Lokal \vs Remote
					\item Zusätzliche Komponente: "Message Broker" \\ Führt zu einem erhöhten Aufwand und zusätzlichem Overhead, aber einer erheblich einfacheren Struktur.
				\end{itemize}
			% end

			\subsection{Laufzeit-Effizienz}
				Insbesondere bei mobilen Robotern ist die Laufzeit-Effizienz enorm wichtig (es werden oftmals tausende Nachrichten pro Sekunde ausgetauscht). Bei jeder Nachricht muss diese dabei serialisiert, in den Speicher kopiert und deserialisiert werden. Diese Übertragung benötigt (auch lokal) Zeit.
				
				Bei einer einzelnen Nachricht in die Latenz gering, aber in der Summe signifikant. Bei einem Echtzeit-Betriebssystem ist dabei nicht unbedingt schnell, aber das Zeitverhalten ist definiert (\dh die Dauer einer Operation ist exakt definiert).
			% end
		% end

		\section{Sicherstellung von Korrektheit und Zuverlässigkeit}
			\begin{itemize}
				\item Aufgrund der Komplexität der Software ist eine formale Verifikation nicht praktikabel (zusätzlich gibt es unendlich viele, nichtlineare und stochastische Einflüsse).
				\item Alternative: Viel testen.
					\begin{itemize}
						\item Korrektheit und Zuverlässigkeit werden anhand einer vordefinierten Menge an Situationen überprüft.
						\item Tritt hierbei kein Fehler auf, so bedeutet das nicht nicht, dass das System "korrekt" ist.
					\end{itemize}
				\item Ansätze im Software Engineering:
					\begin{itemize}
						\item Unit-Tests
						\item Regression-Tests
						\item Integration-Tests
							\begin{itemize}
								\item Durchlaufen möglichst einfach und dennoch repräsentativer Szenarien (Roboter muss Ball finden, zum Ball laufen, ins Tor schießen, \dots).
								\item Ausführen auf dem Roboter ist dabei zeitintensiv (Vorbereitung) und ressourcenintensiv (Verschleiß).
								\item Sofern es möglich ist, sollte die Evaluation in der Simulation stattfinden (Software-in-the-Loop).
							\end{itemize}
						\item Komponenten-Tests
							\begin{itemize}
								\item Abdecken der "low-level" Funktionalität.
								\item Dies ist sinnvoll für einfache Komponenten mit geringer Anzahl an möglichen Eingaben.
								\item Allerdings nicht sinnvoll für das "high-level" Verhalten oder ungenaue und verrauschte Eingangsdaten.
								\item Anwendbar \zB für die Infrastruktur der Middleware (Weiterleitung von Nachrichten, Funktion unter Last, \dots).
							\end{itemize}
					\end{itemize}
			\end{itemize}

			\subsection{Simulation}
				Die Anforderungen an einen Simulator sind sehr unterschiedlich, z.\,B.:
				\begin{itemize}
					\item Testen von Laufbewegungen:
						\begin{itemize}
							\item Ein genaues Dynamikmodell ist unabdingbar.
							\item Hoher Rechenaufwand.
							\item Nur eine kleine Anzahl an Robotern simulierbar.
						\end{itemize}
					\item Testen von Teamverhalten:
						\begin{itemize}
							\item Ein einfaches Kinematikmodell ist ausreichend.
							\item Geringer Rechenaufwand.
							\item Auch mehrere Roboter gleichzeitig simulierbar.
						\end{itemize}
				\end{itemize}
				Ein guter Simulator ermöglicht dementsprechend eine Auswahl von Simulationsmodellen mit unterschiedlichen Abstraktionsebenen und Detaillierungsgraden.
			% end

			\subsection{Automatisierte Testabläufe}
				\begin{itemize}
					\item Die manuelle Durchführung von Testszenarien ist zeitaufwendig und fehleranfällig.
					\item Die Tests können \zB durch Skript automatisiert werden.
						\begin{itemize}
							\item Ein Skript initialisiert das Szenario, positioniert alle Objekte (Roboter, Ball, Hindernisse) in der Szene.
							\item Für jedes Szenario werden Abbruchbedingungen und -zeiten definiert.
							\item Das passende Verhalten zum Szenario wird gestartet.
							\item Die Ergebnisse werden automatisiert erfasst und ausgewertet.
						\end{itemize}
					\item Durch Continuous Integration ist ein zeitnahes Feedback und schnell Eingrenzung von Fehler möglich. Außerdem gibt es eine kontinuierliche Statistik über die Entwicklung der Performanz.
					\item Dadurch wird eine einfache Reproduktion von Problemfällen möglich.
						\begin{itemize}
							\item Nutzung von "ground-truth" Daten zur Vereinfachung, \zB Umgehung der Bildverarbeitung oder Lokalisierung durch die Simulation und nicht mit dem eigentlichen Verfahren.
							\item Dennoch sind die Tests nicht vollständig deterministisch.
						\end{itemize}
					\item Automatisierte Untersuchung auf Regressionen (aufgrund der Komplexität können Seiteneffekte durch Änderungen nicht ausgeschlossen werden).
					\item Das Beheben von Problem ist allerdings noch immer schwierig (die Ursachen für "falsches" Verhalten sind nicht direkt offensichtlich, es sind viele Komponenten beteiligt).
				\end{itemize}
			% end

			\subsection{Monitoring}
				\begin{itemize}
					\item Eine Fehlersuche durch reines "Anschauen des Roboters" ist aufgrund der Komplexität unmöglich.
					\item Daher muss "in den Roboter hinein" geschaut werden.
					\item Dies geschieht \bspw mit einer (grafischen) Benutzerschnittstelle, um intrinsische Daten zu visualisieren.
				\end{itemize}
			% end

			\subsection{Visuelles Debuggen}
				\begin{itemize}
					\item Durch Visualisierung einiger Algorithmen können Fehler schnell erkannt werden.
					\item Beispielsweise kann die Trajektorie des Roboterschwerpunktes visualisiert werden.
					\item Es ist wünschenswert, dass jeder Algorithmus/jedes Modell passende Visualisierungen oder Parametrisierungen zur Verfügung stellt.
				\end{itemize}
			% end

			\subsection{Offline Analyse}
				\begin{itemize}
					\item Die Situation und die intrinsischen Daten eines Roboters ändern sich unter Umständen sehr schnell, sodass sie \ggf unmöglich sind online nachzuverfolgen.
					\item Im Fehlerfall ist \mglw kein Monitoring aktiv, eine nachträgliche Analyse soll jedoch trotzdem möglich sein.
					\item Daher sollten alle ausgetauschten Nachrichten aufgezeichnet werden.
						\begin{itemize}
							\item Mit Nachrichten-basierter Kommunikation ist dies prinzipiell einfach möglich.
							\item Die Aufzeichnung muss jedoch dezentral auf jedem Roboter erfolgen (die Bandbreite/Verfügbarkeit von externen Systemen ist limitiert; externe Kommunikation ist während eines Wettkampfs \mglw durch die Regeln untersagt).
							\item Je nach Menge der Daten reicht die Schreibrate eventuell nicht aus.
						\end{itemize}
					\item Die aufgezeichneten Daten können anschließend abgespielt und analysiert werden.
						\begin{itemize}
							\item Dabei kann die Situation Schritt für Schritt nachvollzogen werden.
						\end{itemize}
				\end{itemize}
			% end

			\subsection{Kooperierendes Verhalten}
				\begin{itemize}
					\item Die Analyse eines einzelnen Roboters ist meistens ungenügend, es müssen alle Informationen aller Teammitglieder betrachtet werden. Dazu müssen die dezentral aufgenommenen Daten synchronisiert werden.
					\item Häufig ist die Spielsituation im Nachhinein unklar, weshalb externe Informationsquellen berücksichtigt werden sollten (\zB ein externes Video des Spielfelds).
					\item Es ist ein synchrones Abspielen von Videos sowie aufgenommenen Daten zur Analyse nötig.
				\end{itemize}
			% end
		% end
	% end

	\chapter{Steuerung autonomer Roboter} % 11.1, 11.2
		\todo{Content}

		\section{Steuerungsarchitekturen} % 11.3
			\todo{Content}

			\subsection{Hierarchisches Steuerungsparadigma} % 11.4, 11.5, 11.6
				\todo{Content}
			% end

			\subsection{Reaktives Steuerungsparadigma} % 11.7, 11.8
				\todo{Content}
			% end

			\subsection{Hybrid deliberativ-reaktives Steuerungsparadigma} % 11.9, 11.10, 11.11
				\todo{Content}
			% end

			\subsection{Beispiel: Subsumption Architecture} % 11.12, 11.13, 11.14, 11.18
				\todo{Content}

				\subsubsection{Schicht 0} % 11.15
					\todo{Content}
				% end

				\subsubsection{Schicht 1} % 11.16
					\todo{Content}
				% end

				\subsubsection{Schicht 2} % 11.17
					\todo{Content}
				% end
			% end
		% end

		\section{Programmierung von Verhalten} % 11.19, 11.20, 11.21, 11.22, 11.23
			\todo{Content}

			\subsection{XABSL} % 11.24, 11.25, 11.26, 11.27, 11.28, 11.29, 11.30
				\todo{Content}
			% end

			\subsection{FlexBE} % 11.31, 11.32
				\todo{Content}

				\subsubsection{Autonomy Level} % 11.33
					\todo{Content}
				% end

				\subsubsection{Beispiel: TurtleBot3} % N/A
					\todo{Content}

					\paragraph{Move Arm} % 11.34, 11.35, 11.36, 11.37, 11.38, 11.39, 11.40, 11.41, 11.42, 11.43, 11.44, 11.45
						\todo{Content}
					% end

					\paragraph{Move Base} % 11.46, 11.47, 11.48
						\todo{Content}
					% end
				% end
			% end
		% end
	% end





	\appendix

	\chapter{Quaternionen} % S.176
		\todo{Content}

		\section{Einleitung} % S.176
			\todo{Content}
		% end

		\section{Rechenregeln} % S.176
			\todo{Content}
		% end

		\section{Umrechnung: Quaternionen zu Rotationsmatrizen und zurück} % S.177
			\todo{Content}
		% end

		\section{Verkettung von Drehungen} % S.177
			\todo{Content}
		% end

		\section{Repräsentation der Koordinaten eines Punktes bei Rotation} % S.177, S.178
			\todo{Content}
		% end

		\section{Vergleich mit anderen Darstellungsarten} % S.179
			\todo{Content}
		% end
	% end

	\chapter{Zusammenhang zwischen Rotationsmatrix, Drehvektor und Drehwinkel} % S.179
		\todo{Content}

		\section{Umwandlung von Drehvektor und Drehwinkel zu Rotationsmatrix} % S.179
			\todo{Content}
		% end

		\section{Umwandlung von Rotationsmatrix zu Drehvektor und Drehwinkel} % S.179, S.180, S.181
			\todo{Content}
		% end
	% end

	\chapter{Notationen} % S.183, S.184
		\todo{Content}
	% end
\end{document}
